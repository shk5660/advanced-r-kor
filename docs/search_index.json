[
["index.html", "Advanced R in Korean Preface", " Advanced R in Korean Jsang 2020-02-14 Preface 공부삼아 Wickham의 Advanced R을 번역하는 프로젝트를 시작했습니다. 경어체를 사용한 것은 순전히 본인의 취향입니다. 스스로 알아먹기 쉬운 느낌으로 의역을 잔뜩했습니다. 번역이 어려운 부분은 원문 그대로 남겼고, 용어는 한/영을 병기했습니다. (@ 블라블라) 형식으로 본인의 생각과 참견을 표현했습니다. "],
["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction 이 챕터는 패스하고 나중에 여유가 생기면 해보겠습니다. "],
["names-values.html", "Chapter 2 Names and values 2.1 Introduction 2.2 Binding basics 2.3 Copy-on-modify 2.4 Object size 2.5 Modify-in-place 2.6 Unbinding and the garbage collector 2.7 Quiz answers 2.8 Summary", " Chapter 2 Names and values 2.1 Introduction R에서는 객체(object)와 이름(name)의 차이를 이해하는 것이 중요합니다. 이를 이해하게 된다면, 더 정확하게 코드의 성능과 메모리 사용을 예측할 수 있습니다. 느린 코드의 주요 원인인 의도치 않은 복사를 피함으로써, 빠른 코드를 작성할 수 있습니다. R의 함수형 프로그래밍 툴에 대해 더욱 잘 이해할 수 있게 됩니다. 이 챕터의 목표는 이름(names)과 값(values)의 차이, 그리고 언제 R이 객체(object)를 복사하는지 이해하도록 돕는 것입니다. Quiz 이 챕터를 넘겨도 될지 다음 문제를 통해 확인해보세요. 이 챕터 끝에 있는 Section 2.7에서 정답을 확인하실 수 있습니다. 주어진 데이터프레임에서, 어떻게 하면 1과 2의 합을 담고 있는 “3”이라는 열을 만들 수 있을까요? [[는 사용하지 말고, $만 이용해보세요. 1, 2, 그리고 3을 변수명으로 사용하기 어렵게 만드는 것은 무엇인가요? df &lt;- data.frame(runif(3), runif(3)) names(df) &lt;- c(1, 2) 주어진 코드에서, y가 차지하는 메모리는 얼마만큼인가요? x &lt;- runif(1e6) y &lt;- list(x, x, x) 주어진 예시에서 a가 복사되는 순간은 몇번째 줄일까요? a &lt;- c(1, 5, 3, 2) b &lt;- a b[[1]] &lt;- 10 Outline Section 2.2는 이름(names)와 값(values)의 차이점을 소개하고, &lt;-가 어떻게 이름과 값 사이의 연결(binding)이나 참조(reference)를 만들어내는지 다룹니다. Section 2.3은 R이 언제 ’복사’를 실행하는지 설명합니다. 벡터를 변형시킬때라면, 거의 대부분 새로운 변형된 벡터를 생성하는 것이라 볼 수 있습니다. tracemem() 을 사용해 언제 복사가 실제로 일어나는지 확인하는 법을 배웁니다. 그리고 이것들이 함수 실행, 리스트, 데이터프레임, 그리고 문자형 벡터들에 어떤 식으로 적용되는지 살펴볼 것입니다. Section 2.4에서는 객체(object)가 얼마나 메모리를 차지하는지에 대해, 이전 두 섹터가 갖는 함의를 알아볼 것입니다. 아마 이에 대한 당신의 직관이 상당히 잘못되어 있을 것이고, 안타깝게도 utils::object.size()가 부정확하기에, lobstr::obj_size()를 사용하는 법을 배울 것입니다. Section 2.5에선 ‘copy-on-modify’(@ 후에 보다 자세히 다루겠지만 ‘변형을 할 때 복사가 일어난다’ 정도로 이해하면 될 것 같습니다.)의 중요한 두가지 예외를 알아볼 것입니다. 환경(environments)과 하나의 이름을 갖는 값에 대해서, 객체는 바로 그 자리에서 변형됩니다. Section 2.6에서는 더이상 이름으로 참조되지 않는 객체에 의해 사용되는 메모리를 비워주는, garbage collector에 대해 살펴보면서 챕터를 마치겠습니다. Prerequisites 우린 R 객체의 내부 표현을 자세히 살펴보기 위해 lobstr 패키지를 사용할 것입니다. library(lobstr) 2.2 Binding basics 이 코드를 한 번 봅시다. x &lt;- c(1, 2, 3) 이 코드는 \" x라는 이름으로, 1, 2, 3이라는 값들을 담는 객체를 만들어라. \" 라는 식으로 해석하기 쉽습니다. 만약 이런 식으로 이해한다면, 아쉽게도 R이 실제로 수면 아래에서 어떤 방식으로 동작하는지에 대해 부정확하게 예측하게 됩니다. 위의 해석보다는 아래의 두가지 액션을 취한다고 말하는 것이 보다 정확합니다. c(1, 2, 3)이라는 값들의 벡터 객체를 만듭니다. 그리고 이 객체를 x라고 하는 이름과 연결시킵니다. 즉, 객체나 값은 이름을 갖는 것이 아닙니다. 실제론 이름이 값을 갖는 것입니다. 이 차이를 명확히 하기 위해, 그림을 하나 그려보겠습니다. x라고 하는 이름은, 둥근 모서리로 된 사각형으로 표현되고 있습니다. 그리고 얘는 벡터 c(1, 2, 3)라는 값을 가리키는(또는 묶어주는, 또는 참조하는) 화살표를 갖고 있습니다. 이 화살표는 할당 연산자인 &lt;-와는 반대 방향을 가리키고 있는데, &lt;-는 왼편에 있는 이름을 오른편에 있는 객체로 묶어(binding)줍니다. 다시 말해, 이름(name)은 값(value)에 대한 참조(reference)라고 생각해도 무방합니다.(@ 참조라는 말이 잘 와닿진 않는데 ‘주소’ 정도로 이해해도 괜찮으려나?) 예를 들어, 아래 코드를 실행하면 c(1, 2, 3)을 복사하지 않습니다. 그저 이미 존재하고 있던 객체에 대한 다른 ’연결’이 생겨날 뿐입니다.(@ 실존하는 하나의 집을, 여러 종류의 주소로 표현할 수 있는 것과 비슷한 느낌) y &lt;- x 아마 c(1, 2, 3)에 0x74b라는 라벨이 붙어있는 것을 발견하셨을 겁니다. 벡터가 이름을 갖진 않지만, 바인딩과는 독립적으로 객체를 참조해야 할 때가 있습니다. 이를 위해, 값에 고유한 식별자(ID)를 부여한 것입니다. 이 ID는 객체의 메모리 ’주소’처럼 생긴 특별한 형식을 가지고 있습니다. 주소라함은 객체가 저장된 메모리의 위치이기 때문입니다. 하지만 실제 메모리 주소는 코드를 실행할 때마다 변하기 때문에, 대신 ID를 사용하기로 합니다. lobstr::obj_addr()을 이용해 객체의 ID에 접근할 수 있습니다. 실제로 사용해보면 x와 y가 같은 ID를 가리키고 있는 것을 볼 수 있습니다. obj_addr(x) #&gt; [1] &quot;0x15f44208&quot; obj_addr(y) #&gt; [1] &quot;0x15f44208&quot; 이 ID들은 길고 R을 재시작할 때마다 바뀝니다. 이름과 값의 차이를 이해하는 데에는 시간이 좀 걸릴 겁니다. 하지만 이해하고나면, 함수형 프로그래밍에 있어 크게 도움이 됩니다. 다른 맥락에서 다른 이름을 가지는 함수들에 대해서 말이죠. 2.2.1 Non-syntactic names R은 유효한 이름에 대해 엄격한 기준을 갖고 있습니다. 문법적으로 올바른(syntactic) 이름은 반드시 글자, 숫자, ., _로만 이루어져야 하며, _나 숫자로 시작할 수는 없습니다. 또한 TRUE, NULL, if, 그리고 function과 같은 예약어(reserved words)는 사용할 수 없습니다.(@ 예약어는 R에서 이미 사용되고 있는 단어들이라고 볼 수 있겠습니다.) 이 규칙들을 따르지 않는 이름을 non-syntactic한 이름이라고 하며, 만약 이를 사용하려고 하면 에러가 납니다. _abc &lt;- 1 #&gt; Error: unexpected input in &quot;_&quot; if &lt;- 10 #&gt; Error: unexpected assignment in &quot;if &lt;-&quot; 이 규칙들을 어기고 어떤 이름이든 사용하는 것도 가능은 합니다. 어떤 종류의 문자열이든 backticks로 감싸주면 됩니다. `_abc` &lt;- 1 `_abc` #&gt; [1] 1 `if` &lt;- 10 `if` #&gt; [1] 10 보통 의도적으로 이런 요상한 이름들을 만들 일은 거의 없겠지만, R 외부에서 만들어진 데이터를 불러올 때 이런 이름들을 흔히 마주칠 수 있기 때문에, 이를 이해할 필요가 있습니다. 2.2.2 Exercises a, b, c, d의 관계를 설명해보세요. a &lt;- 1:10 b &lt;- a c &lt;- b d &lt;- 1:10 아래 코드는 평균 함수에 여러 방식으로 접근하고 있습니다. 이들은 전부 동일한 함수 객체를 가르키고 있는 것일까요? lobstr::obj_addr()을 이용해 확인해보세요. mean base::mean get(&quot;mean&quot;) evalq(mean) match.fun(&quot;mean&quot;) read.csv 같은 R의 기본 데이터 로드 함수는, 자동으로 non-syntactic한 이름들을 syntactic하게 바꿉니다. 이게 왜 문제가 될 수 있을까요? 이런 행태를 억제할 수 있게 해주는 옵션은 무엇인가요? non-syntactic한 이름을 syntactic하게 변환하기 위해 make.names()가 사용하는 규칙은 무엇입니까? 저는 syntactic한 이름을 결정짓는 규칙을 조금 단순화해서 설명했습니다. 왜 .123e1은 syntactic한 이름이 아닐까요? 자세히 알기 위해 ?makes.names를 읽어보세요. 2.3 Copy-on-modify 아래 코드를 살펴봅시다. 이것은 x와 y를 동일한 참조값과 묶어줍니다. 그리고 y를 변형합니다. x &lt;- c(1, 2, 3) y &lt;- x y[[3]] &lt;- 4 x #&gt; [1] 1 2 3 y를 변형하는 것은 분명히 x는 변형시키지 않습니다. 그럼 공유되고 있는 바인딩에는 무슨 일이 일어날까요? y와 연결된 값은 변하지만, 원본 객체는 변하지 않습니다. 대신에, R은 0x74b의 값을 하나 바꾼 0xcd2라는 새로운 복사본을 만들고, y와 다시 연결시켜 줍니다. 이런 현상을 copy-on-modify라고 부릅니다. 이를 이해한다면 R 코드 성능에 대한 직관이 굉장히 향상될 것입니다. 이 특성을 설명하는 다른 표현으로, R 객체는 변경할 수 없다(unchangeable), 또는 불변하다(immutable) 등이 있겠습니다. 그러나 전 이런 용어는 대체로 쓰지 않으려고 하는데, Section 2.5에서 배우게 될 copy-on-modify의 중요한 예외사항들이 있기 때문입니다. copy-on-modify에 대해 알아보려고 할 때, RStudio 내에서는 다른 결과들을 얻게 될 수 있다는 것에 유의하세요. 이건 환경창(environment pane)이 각 객체들에 대한 정보를 보여주기 위해, 각 객체에 대한 참조를 만들어야만 하기 때문입니다. 이는 당신의 인터렉티브한 탐사를 왜곡시킬 수 있지만, 함수 내부에 있는 코드들엔 영향을 미치지 않습니다. 때문에 데이터 분석을 하는 동안에는 성능에 영향도 없습니다. 실험을 위해서라면, 터미널에서 R을 직접 실행하거나, RMarkdown을 이용하는 것을 추천드립니다. 2.3.1 tracemem() base::tracemem()의 도움을 받아 객체가 언제 복사되는지 볼 수 있습니다. 한 번 이 함수를 어떤 객체로 실행하면, 이 객체의 최근 주소를 받아볼 수 있습니다. x &lt;- c(1, 2, 3) cat(tracemem(x), &quot;\\n&quot;) #&gt; &lt;0x7f80c0e0ffc8&gt; 함수를 실행하고나면 객체가 복사될 때마다 tracemem()이 복사된 객체, 그것의 새 주소와 복사를 일으킨 호출 순서를 알려줄 것입니다. y &lt;- x y[[3]] &lt;- 4L #&gt; tracemem[0x7f80c0e0ffc8 -&gt; 0x7f80c4427f40]: 만약 y를 다시 변경하면, 복사는 일어나지 않습니다. 이는 새로운 객체가 이제 오직 하나의 이름에 연결되어 있기에, R이 modify-in-place를 적용하기 때문입니다. 이것에 대해선 Section 2.5에서 다시 알아봅시다. y[[3]] &lt;- 5L untracemem(x) untracemem()은 tracemem()과 반대로, 추적을 종료해줍니다. 2.3.2 Function calls 함수를 호출할 때에도 동일한 복사 규칙이 적용됩니다. 코드를 봅시다. f &lt;- function(a) { a } x &lt;- c(1, 2, 3) cat(tracemem(x), &quot;\\n&quot;) #&gt; &lt;00000000191490C0&gt; z &lt;- f(x) # there&#39;s no copy here! untracemem(x) f()이 실행되는 동안, 함수 내부의 a는 함수 외부의 x와 같은 값을 가리키게 됩니다. 그림에서 나타난 표현법에 대해서는 Section 7.4.4에서 더 배우게 될 것입니다. 간략히 설명하자면, 함수 f()는 오른편 노란색 객체로 표현되었습니다. 이 함수의 인자 a는 함수가 실행될 때, 실행 환경(회색 박스)에서 바인딩(검은 점선)이 됩니다. f()가 완료되면, x와 z는 같은 객체를 가리키게 됩니다. 0x74b는 한 번도 복사되지 않았는데, 변형된 적이 없기 때문입니다. 만약 f()가 x를 변형시키는 함수였다면, R는 새로운 복사본을 만들었을 것이고, 그리고 나서 z가 그 객체와 연결되었을 겁니다. 2.3.3 Lists 값을 가리키는 것은 이름(즉, 변수)만이 아닙니다. 리스트의 원소 역시 동일한 역할을 합니다. 이 리스트는 표면적으로 봤을 때, 위에 나왔던 숫자형 벡터와 매우 비슷합니다. l1 &lt;- list(1, 2, 3) 이 리스트는 사실 벡터보단 더 복잡한데, 값 자체를 저장하는 것이 아니라, 값에 대한 참조들(주소들)을 저장하기 때문입니다. 이는 리스트를 변형하려 할 때 특히 중요하게 작용합니다. l2 &lt;- l1 l2[[3]] &lt;- 4 벡터와 마찬가지로, 리스트도 copy-on-modify 성질을 사용합니다. 원본 리스트는 변하지 않은채 남겨져 있고, 변형된 새 복사본을 만들어 냅니다. 하지만 이는 얕은 복사입니다. 얕은이라고 표현한 것은, 리스트 객체와 해당 바인딩들은 복사되지만, 바인딩이 가리키고 있는 값들은 복사되지 않기 때문입니다. 얕은 복사의 반대는 깊은 복사인데, 이는 모든 참조값들이 복사됩니다. R 3.1.0 버전 이전에는 모든 복사가 깊은 복사였습니다. 리스트들 간에 공유되는 값들을 보려면, lobstr::ref()를 사용하면 됩니다. ref()는 각 객체의 메모리 주소를 로컬 ID와 함께 출력해주기 때문에, 공유된 요소들을 쉽게 상호 참조할 수 있습니다. ref(l1, l2) #&gt; o [1:0x19a6f4a8] &lt;list&gt; #&gt; +-[2:0x19a3d1c0] &lt;dbl&gt; #&gt; +-[3:0x19a3d188] &lt;dbl&gt; #&gt; \\-[4:0x19a3d150] &lt;dbl&gt; #&gt; #&gt; o [5:0x1a3a3538] &lt;list&gt; #&gt; +-[2:0x19a3d1c0] #&gt; +-[3:0x19a3d188] #&gt; \\-[6:0x1a37c500] &lt;dbl&gt; 2.3.4 Data frames 데이터프레임은 벡터들의 리스트입니다. 때문에 데이터프레임을 변형할 때도 copy-on-modify가 중요한 결과를 가져옵니다. 예시로 이 데이터프레임을 봅시다. d1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3)) 만약 열을 변형한다면, 오직 해당 열만 변형되면 됩니다. 다른 열들은 그대로 원래 참조값들을 가리키면 되는 것입니다. d2 &lt;- d1 d2[, 2] &lt;- d2[, 2] * 2 하지만 만약 행을 변형한다면, 모든 열이 바뀝니다. 다시 말해 모든 열이 복사되어야 합니다. d3 &lt;- d1 d3[1, ] &lt;- d3[1, ] * 3 2.3.5 Character vectors R이 참조를 사용하는 마지막 장소는 바로 문자형 벡터입니다. 전 보통 문자형 벡터들을 이런 식으로 표현합니다. x &lt;- c(&quot;a&quot;, &quot;a&quot;, &quot;abc&quot;, &quot;d&quot;) 하지만 이건 좀 예의바른 예시입니다. R은 실제로 global string pool을 이용하는데, 문자형 벡터의 각 요소들이 고유한 문자 풀에 대한 포인터가 됩니다. ref()의 character 변수를 TRUE로 세팅하면 이 참조값들을 볼 수 있습니다. ref(x, character = TRUE) #&gt; o [1:0x189d22a0] &lt;chr&gt; #&gt; +-[2:0x12f37598] &lt;string: &quot;a&quot;&gt; #&gt; +-[2:0x12f37598] #&gt; +-[3:0x180ca668] &lt;string: &quot;abc&quot;&gt; #&gt; \\-[4:0x13135230] &lt;string: &quot;d&quot;&gt; 이는 문자형 벡터가 차지하는 메모리 사용량에 큰 영향을 미치는데, 일반적으로 그리 중요하진 않으므로, 책의 다른 부분에서는 문자열이 벡터 내부에 있는 것처럼 문자형 벡터를 표현할 것입니다. 2.3.6 Exercises 왜 tracemem(1:10)은 별로 쓸모가 없습니까? 이 코드를 실행했을 때, 왜 tracemem()이 복사를 두번 보여주는지 설명해보세요. 힌트: 이 코드와 이전 내용에서 등장했던 코드의 차이점을 유심히 살펴보세요. x &lt;- c(1L, 2L, 3L) tracemem(x) x[[3]] &lt;- 4 주어진 객체들간의 관계를 그려보세요. a &lt;- 1:10 b &lt;- list(a, a) c &lt;- list(b, a, 1:10) 이 코드를 실행하면 무슨 일이 일어날까요? x &lt;- list(1:10) x[[2]] &lt;- x 그림을 그려보세요. 2.4 Object size lobstr::obj_size()를 사용하면 객체가 얼마 만큼의 메모리를 차지하는지 확인할 수 있습니다. obj_size(letters) #&gt; 1,712 B obj_size(ggplot2::diamonds) #&gt; 3,456,344 B 리스트의 요소들은 값들에 대한 참조들이기 때문에, 리스트의 크기는 아마 예상했던 것보단 훨씬 작을 것입니다. x &lt;- runif(1e6) obj_size(x) #&gt; 8,000,048 B y &lt;- list(x, x, x) obj_size(y) #&gt; 8,000,128 B y는 x보다 고작 80바이트가 큰데, 이건 세 개의 요소를 가진 빈 리스트의 크기입니다. obj_size(list(NULL, NULL, NULL)) #&gt; 80 B 비슷하게, R이 global string pool을 사용하기 때문에 문자형 벡터들 역시 예상보다 적은 메모리를 차지합니다. 문자를 100번 반복한다고 해서 메모리가 100배 커지지 않는다는 이야기입니다. banana &lt;- &quot;bananas bananas bananas&quot; obj_size(banana) #&gt; 136 B obj_size(rep(banana, 100)) #&gt; 928 B 참조들은 또한 개별 객체들의 크기에 대해서 생각하기 어렵게 만듭니다. obj_size(x) + obj_size(y)는 공유되는 값이 없을 때에만 obj_size(x, y)와 크기가 같을 것입니다. 여기에선, x와 y를 결합한 크기가 y의 크기와 동일합니다. obj_size(x, y) #&gt; 8,000,128 B 마지막으로, 3.5.0 이후 버전의 R은 ALTREP이라는 조금 놀라운 특징을 가지고 있는데, 이것은 alternative representation의 줄임말입니다. 이는 R이 특정 타입의 벡터들을 매우 간결히 표현할 수 있게 해줍니다. 이 현상을 주로 볼 수 있는 것은 :를 사용할 때인데, 수열의 모든 숫자들을 저장하는 대신 처음과 마지막 숫자만 저장하면 되기 때문입니다. 이는 모든 수열에서, 아무리 크다고 할지라도 같은 크기라는 것을 의미합니다. obj_size(1:3) #&gt; 680 B obj_size(1:1e3) #&gt; 680 B obj_size(1:1e6) #&gt; 680 B obj_size(1:1e9) #&gt; 680 B 2.4.1 Exercises 다음 예시에서, 왜 object.size(y)와 obj_size(y)가 엄청나게 다른 것일까요? object.size()의 문서를 참고해보세요. y &lt;- rep(list(runif(1e4)), 100) object.size(y) #&gt; 8005648 bytes obj_size(y) #&gt; 80,896 B 아래의 리스트에서, 왜 이것의 크기는 오해의 소지가 있을까요? funs &lt;- list(mean, sd, var) obj_size(funs) #&gt; 17,608 B 다음 코드의 결과를 예상해보세요. a &lt;- runif(1e6) obj_size(a) #&gt; 8,000,048 B b &lt;- list(a, a) obj_size(b) #&gt; 8,000,112 B obj_size(a, b) #&gt; 8,000,112 B b[[1]][[1]] &lt;- 10 obj_size(b) #&gt; 16,000,160 B obj_size(a, b) #&gt; 16,000,160 B b[[2]][[1]] &lt;- 10 obj_size(b) #&gt; 16,000,160 B obj_size(a, b) #&gt; 24,000,208 B 2.5 Modify-in-place 위에서 살펴본 것처럼, R 객체를 변형하는 것은 보통 복사본을 만들어냅니다. 이에는 두 가지 예외가 있습니다. 하나의 바인딩만 있는 객체는 특별한 성능 최적화를 얻습니다. 특별한 객체 타입인 환경(Environments)들은 항상 그 자리에서 변형됩니다.(modified in place) 2.5.1 Objects with a single binding 객체가 오직 하나의 이름에게 바인딩되어 있다면, R은 그것을 그 자리에서 변형합니다. v &lt;- c(1, 2, 3) v[[3]] &lt;- 4 (객체 ID를 유의해서 보면, v는 0bx207이라는 객체와 계속 연결되어 있습니다.) 두 가지 요소가 R이 정확히 언제 이 최적화를 적용하는지 예측하기 힘들게 합니다. 바인딩과 관련해서, R은 현재 0, 1 또는 여럿만을 카운팅할 수 있습니다. 이말인즉슨, 만약 객체가 바인딩을 두 개 가지고 있고, 하나가 사라진다면, 참조 카운트 수가 1로 돌아가지 않는다는 것입니다. 여럿보다 하나 적은 것은 여전히 여럿이기 때문입니다. 결과적으로 R이 필요하지 않을 때에도 복사본을 만들게 됩니다. 대부분의 함수들을 호출할때마다, 그것은 객체에 대해 참조를 만듭니다. 유일한 예외는 특별히 작성된 “원시” C 함수를 이용할 때 뿐입니다. 이것들은 R-core에서만 쓸 수 있고 기본 패키지에서는 대부분 발생합니다. 이 두 요소 때문에 복사가 일어날지 아닐지 예측하는 게 어렵습니다. R의 For 반복문은 느리기로 유명한데, 이 느릿함은 종종 반복문의 매 시행마다 복사본을 만들기 때문에 생겨납니다. 아래 코드를 봅시다. 이건 큰 데이터프레임의 각 열에서 중앙값을 뽑아냅니다. x &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5)) medians &lt;- vapply(x, median, numeric(1)) for (i in seq_along(medians)) { x[[i]] &lt;- x[[i]] - medians[[i]] } 이 loop는 겁나게 느린데, 매 loop를 반복 할때마다 데이터프레임을 복사하기 때문입니다. tracemem()을 이용해서 이를 확인할 수 있습니다. cat(tracemem(x), &quot;\\n&quot;) #&gt; &lt;0x7f80c429e020&gt; for (i in 1:5) { x[[i]] &lt;- x[[i]] - medians[[i]] } #&gt; tracemem[0x7f80c429e020 -&gt; 0x7f80c0c144d8]: #&gt; tracemem[0x7f80c0c144d8 -&gt; 0x7f80c0c14540]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c14540 -&gt; 0x7f80c0c145a8]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c145a8 -&gt; 0x7f80c0c14610]: #&gt; tracemem[0x7f80c0c14610 -&gt; 0x7f80c0c14678]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c14678 -&gt; 0x7f80c0c146e0]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c146e0 -&gt; 0x7f80c0c14748]: #&gt; tracemem[0x7f80c0c14748 -&gt; 0x7f80c0c147b0]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c147b0 -&gt; 0x7f80c0c14818]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c14818 -&gt; 0x7f80c0c14880]: #&gt; tracemem[0x7f80c0c14880 -&gt; 0x7f80c0c148e8]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c148e8 -&gt; 0x7f80c0c14950]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c14950 -&gt; 0x7f80c0c149b8]: #&gt; tracemem[0x7f80c0c149b8 -&gt; 0x7f80c0c14a20]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c14a20 -&gt; 0x7f80c0c14a88]: [[&lt;-.data.frame [[&lt;- untracemem(x) 사실, 반복할 때마다 데이터프레임은 한 번도 아니고, 두 번도 아닌, 무려 세 번이나 복사됩니다. 복사 두 번은 [[.data.frame에 의해 일어나고, 또 한 번의 복사는 [[.data.frame이 x의 참조 횟수를 증가시키는 정규함수(regular function)이기 때문에 일어납니다.(@ 무슨 말인지 모르겠따…) 데이터프레임 대신에 리스트를 사용하면 복사 횟수를 줄일 수 있습니다. 리스트를 변형시키는 것은 내장된 C 코드를 사용하기 때문에, 참조는 증가하지 않고 오직 한 번의 복사만 일어납니다. y &lt;- as.list(x) cat(tracemem(y), &quot;\\n&quot;) #&gt; &lt;0x7f80c5c3de20&gt; for (i in 1:5) { y[[i]] &lt;- y[[i]] - medians[[i]] } #&gt; tracemem[0x7f80c5c3de20 -&gt; 0x7f80c48de210]: 언제 복사가 일어날지 결정하는 것은 어렵지 않지만, 그것을 방지하는 것은 어렵습니다. 만약 복사를 피하는 재밌는 트릭들에 흥미를 느끼셨다면, Chapter 25에서 만나게 될 C++로 당신의 함수를 다시 쓸 때인지도 모르겠습니다. 2.5.2 Environments Chapter 7에서 환경에 대해서 더 자세히 배우겠지만, 지금 한 번 언급하려고 합니다. 왜냐하면 환경이 작동하는 방식이 다른 객체들의 것과 다르기 때문입니다. 환경은 항상 바로 그 자리에서 변형됩니다.(modified in place) 이 특성은 가끔 reference semantics이라고 표현되는데, 환경을 변형할 때는 그 환경에 대해 존재하는 모든 바인딩들이 같은 참조를 가지는 것이 유지되기 때문입니다. 이 환경을 한 번 봅시다. e1과 e2를 엮었습니다. e1 &lt;- rlang::env(a = 1, b = 2, c = 3) e2 &lt;- e1 만약 이 바인딩을 바꾸면, 환경은 modified in place 됩니다. e1$c &lt;- 4 e2$c #&gt; [1] 4 이 기본적인 아이디어는 이전의 상태를 “기억하는” 함수를 만들기 위해 사용할 수 있습니다. Section 10.2.4에서 자세히 다루겠습니다. 또한 이 특성은 Chapter 14의 주제인, R6 객체지향 프로그래밍을 위한 도구로도 사용됩니다. 이 결과 중의 하나로, 환경들은 그 자신을 담을 수도 있습니다. e &lt;- rlang::env() e$self &lt;- e ref(e) #&gt; o [1:0x1884dd30] &lt;env&gt; #&gt; \\-self = [1:0x1884dd30] 이건 환경만이 가진 고유한 특징입니다! 2.5.3 Exercises 왜 아래의 코드가 순환적인 리스트를 만들지 않는지 설명해보세요. x &lt;- list() x[[1]] &lt;- x 중앙값을 추출하는 두 방법을 두 함수로 만든 다음, ‘bench’ 패키지를 이용해서 속도를 비교해보세요. 열의 수가 증가함에 따라 성능이 어떻게 변하나요? tracemem()을 환경에 사용하려고 하면 어떤 일이 일어나나요? 2.6 Unbinding and the garbage collector 이 코드를 봐주세요. x &lt;- 1:3 x &lt;- 2:4 rm(x) 우리는 두 개의 객체를 만들었습니다. 하지만 코드가 끝나면서, 두 객체 모두 이름과의 연결이 끊어졌습니다. 그럼 어떻게 이 객체들은 지워지게 될까요? 이것이 garbage collector의 역할입니다.(줄여서 GC라고 합시다.) GC는 더 이상 사용되지 않는 R 객체를 삭제하거나, 만약 필요하다면 운영체제에게 메모리를 더 요청하여, 메모리를 비워줍니다. R은 추적(tracing) GC를 사용합니다. 이는 글로벌 환경에서 도달할 수 있는 모든 객체와, 해당 객체에서 다시 도달할 수 있는 모든 객체들을 추적한다는 뜻입니다.(즉, 리스트와 환경에 있는 참조들은 재귀적으로 검색됩니다.) GC는 위에서 언급되었던 modify-in-place 참조 카운트를 사용하지 않습니다. 이 두 아이디어가 밀접하게 연관되어있지만, 내부 데이터 구조는 여러가지 사용 케이스에 맞게 되적화됩니다.(@ 이 부분은 정말 무슨 말인지 모르겠다…) GC는 R이 새로운 객체를 만들기 위해 더 많은 메모리가 필요할 때면, 자동으로 작동합니다. 외부에서 봤을 때, 언제 GC가 작동할지 예측하는 것은 기본적으로 불가능합니다. 사실, 시도할 필요도 없습니다. 만약 GC가 언제 작동하는지 알아내고 싶을 때 gcinfo(TRUE)를 호출하면, GC가 돌아갈 때마다 콘솔에 메시지를 출력해 줄 것입니다. gc()를 호출해서 garbage collection을 강제할 수도 있습니다. 하지만 gc()를 직접 호출할 필요는 전혀 없습니다. gc()를 호출하고 싶은 유일한 이유는 다른 프로그램들이 사용할 수 있도록 R에게 메모리를 운영체제로 돌려주도록 요청하거나, 현재 얼마 만큼의 메모리가 사용되고 있는지 말해주는 부가 효과 때문일 겁니다. gc() #&gt; used (Mb) gc trigger (Mb) max used (Mb) #&gt; Ncells 580341 31.0 1264255 67.6 1264255 67.6 #&gt; Vcells 1078798 8.3 8388608 64.0 2151253 16.5 lobstr::mem_used()는 gc()의 래퍼함수도, 사용되고 있는 모든 바이트의 수를 출력합니다. mem_used() #&gt; 41,168,296 B 이 숫자는 당신의 운영체제에서 보고하는 메모리 양과 일치하진 않을텐데, 이에는 세가지 이유가 있습니다. 이는 R 인터프리터가 아닌 R에 의해 생성된 객체들을 포함하고 있습니다. R과 운영체제가 둘 다 게으르기 때문입니다. 얘네들은 실제로 필요하기 전까진 메모리를 반환하지 않습니다. R이 메모리를 붙잡고 있을수도 있는데, OS가 아직 돌려달라고 하지 않았기 때문입니다. R은 객체가 차지하는 메모리를 계산합니다. 하지만 지워진 객체들 때문에 차이가 생길 수 있습니다. 이런 문제를 메모리 분열(fragmentation)이라고 합니다. 2.7 Quiz answers non-syntactic한 이름을 backticks(`)로 감싸주면 됩니다. df &lt;- data.frame(runif(3), runif(3)) names(df) &lt;- c(1, 2) df$`3` &lt;- df$`1` + df$`2` 8MB를 차지합니다. x &lt;- runif(1e6) y &lt;- list(x, x, x) obj_size(y) #&gt; 8,000,128 B a는 b가 변형되는 b[[1]] &lt;- 10에서 복사됩니다. 2.8 Summary 객체나 값이 이름을 갖는 것이 아니라, 이름이 값을 갖는 것이다. R에서는 객체를 변형할 때, 복사가 일어난다. 참조라고 하는 개념 때문에, 객체의 크기는 아마 생각보다 작을 것이다. 단일 이름 객체와 환경은 modified-in-place 된다. "],
["vectors.html", "Chapter 3 Vectors 3.1 Introduction 3.2 Atomic vectors 3.3 Attributes 3.4 S3 atomic vectors 3.5 Lists 3.6 Data frames and tibbles 3.7 NULL 3.8 Quiz answers 3.9 Summary", " Chapter 3 Vectors 3.1 Introduction 이 Chapter에서는 R의 기본 데이터 타입들 중 가장 중요한, 벡터에 대해 이야기하려 합니다. 아마 당신은 여러 종류의 벡터들을 이미 사용해왔겠지만, 아마 그것들이 서로 어떤 연관성이 있는지에 대해서는 깊게 생각해보지 않았을 겁니다. 이번 Chapter에서 모든 벡터 타입들을 너무 자세히 다루지는 않겠지만, 이 타입들이 전체적으로 어떻게 들어맞는지 보여드리겠습니다. 만약 더 자세히 알고 싶다면, R 문서를 찾아보시면 되겠습니다. 벡터는 두가지 맛이 있는데, 원자(atomic) 벡터와 리스트입니다. 이들은 가지고 있는 원소 타입에 차이가 있는데, 원자 벡터는 모든 원소가 반드시 같은 타입이어야만 하고, 리스트는 다른 타입의 원소들을 가질 수 있습니다. 벡터는 아니지만, NULL도 벡터와 밀접히 관련되어 있고, 종종 길이가 0인 일반 벡터의 역할을 하기도 합니다. 이 다이어그램이 기본적인 관계들을 표현해주고 있습니다. Chapter가 진행됨에 따라 다이어그램을 확장해보겠습니다. 모든 벡터는 또한 _특성(attribute)_를 가질 수 있는데, 이름이 붙은 임의의 메타데이터라고 볼 수 있습니다. 특성 중 두 개가 특별히 중요합니다. 차원(dimension) 특성은 벡터를 행렬(matrices)이나 배열(array)로 바꿔주고, 클래스(class) 특성은 S3 객체 시스템을 강화합니다. S3를 어떻게 사용하는 지는 Chapter 13에서 배우겠지만, 여기에서도 가장 중요한 S3 벡터인 팩터(factors), 날짜 시간(date and times), 데이터 프레임(data frames), 그리고 티블(tibbles)에 대해 배울 것입니다. 행렬이나 데이터 프레임 같은 2D 구조들은 딱히 벡터 같다고 생각되지 않을 수 있는데, 왜 R이 이들을 벡터로 간주하는지도 배우게 됩니다. Quiz 이 짧은 퀴즈를 풀어보고 이 Chapter를 읽을 필요가 있는지 확인해 봅시다. 만약 답이 금방 떠오른다면, 이 Chapter를 편안히 넘겨도 됩니다. Section 3.8에서 답을 확인해보세요. 네 가지 일반적인 유형의 atomic 벡터는 무엇입니까? 두 가지 희귀한 유형은 무엇인가요? 특성(attributes)가 무엇입니까? 어떻게 구할 수 있고 설정할 수 있습니까? 리스트는 atomic 벡터와 어떻게 다른가요? 또 행렬은 데이터 프레임과 어떻게 다릅니까? 행렬인 리스트를 가질 수 있습니까? 데이터 프레임이 행렬을 열로 가질 수 있습니까? 티블(tibbles)는 데이터 프레임과 어떻게 다르게 동작합니까? Outline Section 3.2에서는 논리형(logical), 정수형(integer), 실수형(double), 문자형(character)이라는 atomic 벡터들을 소개하겠습니다. 이는 R의 가장 간단한 데이터 구조들입니다. Section 3.3에서는 R의 유연한 메타데이터 설명서인 특성(attributes)를 논합니다. 가장 중요한 특성들은 이름(names), 차원(dimensions), 그리고 클래스(class)입니다. Section 3.4는 atomic 벡터와 특별한 특성이 결합되어 만들어진 중요한 벡터 타입들에 대해 다룹니다. 이는 팩터(factors), 날짜(dates), 날짜-시간(date-times), 그리고 지속시간(durations)를 포함합니다. Section 3.5에선 리스트를 깊게 살펴봅니다. 리스트는 atomic 벡터와 매우 비슷하지만, 한가지 중요한 차이가 있습니다. 바로 리스트는 다른 리스트를 포함해 모든 데이터 타입을 원소로 가질 수 있다는 것입니다. 이 특징은 계층적인 데이터를 표현하기 적합하게 만들어줍니다. Section 3.6은 데이터 프레임과 티블에 대해 가르쳐줍니다. 이들은 직사각형 모양 데이터를 나타낼 때 사용됩니다. 또한 리스트와 행렬의 특징이 결합되어 있어, 통계적 데이터를 다루는 데에도 매우 적합한 구조입니다. 3.2 Atomic vectors 논리형(logical), 정수형(integer), 실수형(double), 문자형(character)은 atomic 벡터의 네 가지 기본 유형입니다. 정수형과 실수형 벡터들은 합쳐서 숫자형(numeric) 벡터로도 알려져 있습니다. 복소수형(complex)과 Raw 타입은 두 가지 희귀 유형입니다. 이들을 더 깊게 다루지는 않으려고 하는데, 복소수형은 통계학에서는 거의 쓸 일이 없고, raw 벡터는 binary 데이터를 다룰 때만 필요한 특수한 유형이기 때문입니다. 3.2.1 Scalars 각 네 가지 기본 타입들은 개별 값을 생성하기 위해, 일명 _scalar_라고 하는 특별한 문법을 갖고 있습니다. 논리형은 풀 네임(TRUE 또는 FALSE), 또는 축약 버전(T 또는 F)으로 쓸 수 있습니다. 실수형은 10진법(0.1234), 지수표기법(1.23e4), 또는 16진법(0xcafe) 형태로 표기될 수 있습니다. 실수형에만 있는 세 가지 특별한 값이 있습니다. Inf, -Inf, 그리고 NaN(not a number)인데, 이들은 부동 소수점 표준에 의해 정의된 특수한 값입니다. 정수형은 실수형과 비슷하게 쓰여지지만 반드시 L를 뒤에 붙여주어야 합니다.(1234L, 1e4L, 또는 0xcafeL) 그리고 분수를 포함할 수 없습니다. 문자형은 \"(\"hi\") 또는 '('bye')로 감싸집니다. 특수한 문자들은 \\를 이용해 이스케이프 할 수 있는데, 자세한 내용은 ?Quotes에서 확인하세요. 3.2.2 Making longer vectors with c() 짧은 벡터들을 가지고 더 긴 벡터들을 만들고 싶다면, c()를 사용하세요. lgl_var &lt;- c(TRUE, FALSE) int_var &lt;- c(1L, 6L, 10L) dbl_var &lt;- c(1, 2.5, 4.5) chr_var &lt;- c(&quot;these are&quot;, &quot;some strings&quot;) 인풋값이 atomic 벡터라면, c()는 항상 다른 atomic 벡터를 만들어냅니다. c(c(1, 2), c(3, 4)) #&gt; [1] 1 2 3 4 다이어그램에서 벡터들은 연결된 직사각형으로 표현했습니다. 위의 코드는 아래와 같이 표현할 수 있습니다. typeof()를 이용해서 벡터의 타입을, length()로 길이를 확인할 수 있습니다. typeof(lgl_var) #&gt; [1] &quot;logical&quot; typeof(int_var) #&gt; [1] &quot;integer&quot; typeof(dbl_var) #&gt; [1] &quot;double&quot; typeof(chr_var) #&gt; [1] &quot;character&quot; 3.2.3 Missing values R은, 특수한 값인 NA(not applicable의 약자)를 이용해서 결측값이나 미지의 값을 나타냅니다. 결측값은 전염되는 성질이 있습니다. 결측값을 포함하는 대부분의 연산은 또 다른 결측값을 내놓습니다. NA &gt; 5 #&gt; [1] NA 10 * NA #&gt; [1] NA !NA #&gt; [1] NA 이 규칙에는 몇 가지 예외가 있는데, 모든 가능한 입력값에 대해 동일한 결과를 도출하는 경우에만 발생합니다. NA ^ 0 #&gt; [1] 1 NA | TRUE #&gt; [1] TRUE NA &amp; FALSE #&gt; [1] FALSE 결측치가 옮겨가는 현상 때문에 벡터 안의 결측값을 찾아내려 할 때 흔히 실수가 발생합니다. x &lt;- c(NA, 5, NA, 10) x == NA #&gt; [1] NA NA NA NA 한 결측값이 다른 것과 같은 값을 가지리란 보장이 없기 때문에, 이러한 결과는 합당하다고 볼 수 있습니다. 대신에 is.na()를 사용하면 결측의 존재를 확인할 수 있습니다. is.na(x) #&gt; [1] TRUE FALSE TRUE FALSE 3.2.4 Testing and coercion 일반적으로 is.*() 함수로 벡터가 주어진 타입의 것인지 _테스트_할 수 있습니다. 하지만 이 함수들은 주의해서 사용해야합니다. is.logical(), is.integer(), is.double(), 그리고 is.character()은 우리가 예상하는대로, 벡터가 문자형인지 실수형인지 정수형인지 논리형인지 확인해줍니다. is.vector(), is.atomic(), is.numeric()은 사용하지 마세요. 이들은 벡터인지 atomic 벡터인지 숫자형인지 확인하지 않습니다. 문서를 주의깊게 읽어 이들이 실제로 무엇을 하는지 알아보세요. atomic vectors에게, 타입은 벡터 전체의 성질입니다. 모든 원소가 같은 타입을 가져야하니까요. 만약 다른 타입들을 결합하려한다면, 지정된 순서에 따라 _강제(coerced)_됩니다. 순서 : 문자형 → 실수형 → 정수형 → 논리형 예를 들어, 문자형과 정수형의 결합은 문자형이 됩니다. str(c(&quot;a&quot;, 1)) #&gt; chr [1:2] &quot;a&quot; &quot;1&quot; Coercion은 대개 자동으로 일어납니다. 대부분의 수학 관련 함수들(+, log, abs 등)은 숫자로 강제합니다. 이런 종류의 coercion은 논리형 벡터들에 대해 특히 유용한데, TRUE는 1이 되고 FALSE는 0이 되기 때문입니다. x &lt;- c(FALSE, FALSE, TRUE) as.numeric(x) #&gt; [1] 0 0 1 # Total number of TRUEs sum(x) #&gt; [1] 1 # Proportion that are TRUE mean(x) #&gt; [1] 0.333 as.logical(), as.integer(), as.double(), as.character()과 같은 as.*() 함수를 사용해서 고의적으로 강제할 수 있습니다. 문자를 강제하는데 실패하는 경우 경고와 결측값이 생깁니다. as.integer(c(&quot;1&quot;, &quot;1.5&quot;, &quot;a&quot;)) #&gt; Warning: 강제형변환에 의해 생성된 NA 입니다 #&gt; [1] 1 1 NA 3.2.5 Exercises raw와 complex scalar를 어떻게 만들 수 있을까요? 아래의 결과물을 예상하며 벡터 coercion에 대한 지식을 확인해보세요. c(1, FALSE) c(&quot;a&quot;, 1) c(TRUE, 1L) 왜 1 ==\"1\"이 참일까요? 왜 -1 &lt; FALSE는 참일까요? 왜 \"one\" &lt; 2는 거짓일까요? 왜 디폴트 NA는 논리형 벡터일까요? 논리형 벡터의 특별한 점은 무엇인가요?(힌트: c(FALSE, NA_character_)를 생각해보세요) 정확히 is.atomic(), is.numeric(), is.vector()는 무엇을 테스트하나요? 3.3 Attributes 아마 atomic 벡터 시리즈가 행렬, 배열, 팩터, 날짜-시간 데이터와 같이 많은 중요한 데이터 구조들을 포함하지 않는다는 사실을 눈치채셨을 것 같습니다. 이 타입들은 atomic 벡터에 속성(attributes)를 추가하여 구축됩니다. 이 Section에서는 속성의 기초와, 어떻게 차원(dim) 속성이 행렬과 배열을 만들어 내는지 배웁니다. 다음 Section에서 어떻게 클래스 속성이 팩터, 날짜, 날짜-시간과 같은 S3 벡터들을 만드는지 배우겠습니다. 3.3.1 Getting and setting 속성이란 객체에 메타데이터를 더해주는 이름과 값의 쌍이라고 볼 수 있습니다. 개개의 속성들은 attr()를 사용하여 검색하거나 수정할 수 있고, attributes()를 사용하여 전체를 검색하고 structure()를 사용해서 일괄 설정할 수 있습니다. a &lt;- 1:3 attr(a, &quot;x&quot;) &lt;- &quot;abcdef&quot; attr(a, &quot;x&quot;) #&gt; [1] &quot;abcdef&quot; attr(a, &quot;y&quot;) &lt;- 4:6 str(attributes(a)) #&gt; List of 2 #&gt; $ x: chr &quot;abcdef&quot; #&gt; $ y: int [1:3] 4 5 6 # Or equivalently a &lt;- structure( 1:3, x = &quot;abcdef&quot;, y = 4:6 ) str(attributes(a)) #&gt; List of 2 #&gt; $ x: chr &quot;abcdef&quot; #&gt; $ y: int [1:3] 4 5 6 속성은 일반적으로는 일시적이라고 생각해야 합니다. 예를 들어, 대부분의 속성들은 대부분의 연산에 의해 사라집니다. attributes(a[1]) #&gt; NULL attributes(sum(a)) #&gt; NULL 일상적으로 보존되는 속성은 두가지 뿐입니다. 이름(names): 각 요소에 이름을 부여하는 문자형 벡터입니다. 차원(dim): dimensions의 약자로, 벡터를 행렬이나 배열로 만들어주는 정수형 벡터입니다. 다른 속성들을 보존하기 위해선, Chapter 13의 주제인, S3 클래스를 만들어 사용해야 합니다. 3.3.2 Names 세 가지 방식으로 벡터에 이름을 부여할 수 있습니다. # When creating it: x &lt;- c(a = 1, b = 2, c = 3) # By assigning a character vector to names() x &lt;- 1:3 names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # Inline, with setNames(): x &lt;- setNames(1:3, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) attr(x, \"names\")는 names(x)에 비해 타이핑도 많이 해야하고 가독성이 떨어지므로 사용을 피해주세요. unname(x) 또는 names(x) &lt;- NULL을 사용해 벡터의 이름을 제거할 수도 있습니다. 기술적으로 정확히 하기 위해, 이름이 있는 벡터 x를 그릴 때는 다음과 같이 그려야 합니다. 하지만 이름은 너무 특별하고 중요하기 때문에, 데이터의 속성 구조에 각별히 주의를 기울이지 않는 한은, 벡터에 직접 라벨을 주도록 하겠습니다. 문자를 이용한 서브 세팅의 편리를 위해, 이름은 고유해야하고 결측이 아니어야만 합니다. 하지만 이건 R이 강제하는 바는 아닙니다. 이름이 어떻게 설정되냐에 따라, 누락된 이름은 \"\" 또는 NA_character_이 될 수도 있습니다. 만약 모든 이름이 누락되어 있다면, names()는 NULL을 반환합니다. 3.3.3 Dimensions dim 속성을 벡터에 추가하는 것은 벡터가 2차원 _행렬_이나 다차원 _배열_처럼 작동할 수 있게 해줍니다. 행렬과 배열은 주로 수학이나 통계학적 도구이지, 프로그래밍 도구는 아닙니다. 따라서 이들은 자주 사용되지는 않으므로 이 책에서는 간략히 다루겠습니다. 이것들의 가장 중요한 특징은 Section 4.2.3에서 다룰 다차원 세브세팅입니다. 행렬과 배열을 만들기 위해서는 matrix()와 array()를 사용하거나, dim() 형태의 할당을 사용할 수 있습니다. # Two scalar arguments specify row and column sizes a &lt;- matrix(1:6, nrow = 2, ncol = 3) a #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 # One vector argument to describe all dimensions b &lt;- array(1:12, c(2, 3, 2)) b #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 7 9 11 #&gt; [2,] 8 10 12 # You can also modify an object in place by setting dim() c &lt;- 1:6 dim(c) &lt;- c(3, 2) c #&gt; [,1] [,2] #&gt; [1,] 1 4 #&gt; [2,] 2 5 #&gt; [3,] 3 6 벡터에 작동하는 많은 함수들은 행렬과 배열에도 일반화가 가능합니다. Vector Matrix Array names() rownames(), colnames() dimnames() length() nrow(), ncol() dim() c() rbind(), cbind() abind::abind() — t() aperm() is.null(dim(x)) is.matrix() is.array() dim 속성이 없는 벡터는 1차원으로 생각되지만, 실제로는 NULL 차원입니다. 하나의 행이나 열을 가지는 행렬이나, 1차원인 배열도 만들 수 있습니다. 이들은 비슷하게 출력되지만, 다르게 동작합니다. 이 차이점들은 그리 중요하진 않지만, 알아두면 함수가 이상한 결과물을 뱉는 경우에 유용할 수 있습니다.(tapply()가 빈번히 이럽디다) 뭐 여느때와 마찬가지로, str()을 이용해서 차이점을 확인할 수 있습니다. str(1:3) # 1d vector #&gt; int [1:3] 1 2 3 str(matrix(1:3, ncol = 1)) # column vector #&gt; int [1:3, 1] 1 2 3 str(matrix(1:3, nrow = 1)) # row vector #&gt; int [1, 1:3] 1 2 3 str(array(1:3, 3)) # &quot;array&quot; vector #&gt; int [1:3(1d)] 1 2 3 3.3.4 Exercises setNames()와 unname()은 어떻게 구현되어 있습니까? 소스 코드를 읽어보세요. dim()이 1차원 벡터에게 적용되었을 때 무엇이 반환됩니까? NROW()나 NCOL()은 언제 사용하나요? 다음 세 객체를 어떻게 설명하시겠습니까? 1:5와 다른 점이 무엇인가요? x1 &lt;- array(1:5, c(1, 1, 5)) x2 &lt;- array(1:5, c(1, 5, 1)) x3 &lt;- array(1:5, c(5, 1, 1)) 초기 원고에서는 structure()를 표현하기 위해 이 코드를 사용했었습니다. structure(1:5, comment = &quot;my attribute&quot;) #&gt; [1] 1 2 3 4 5 하지만 이 객체를 프린트하면 comment 속성을 볼 수 없습니다. 왜일까요? 속성이 누락된 것일까요? 아니면 뭔가 특별한 것이 있는 걸까요?(힌트: help를 사용해보세요) 3.4 S3 atomic vectors 벡터의 가장 중요한 속성 중 하나는 S3 객체 시스템의 근간을 이루는 class입니다. 클래스 속성을 가지게 되면 객체가 S3 객체로 바뀝니다. 이는 제네릭(generic) 함수를 거쳤을 때, 일반적인 벡터와는 다른 행태를 보인다는 것을 의미합니다. 모든 S3 객체는 기본 타입을 기반으로 형성되고, 종종 다른 속성들에 대한 추가 정보를 저장하기도 합니다. Chapter 13에서 S3 객체 시스템에 대한 디테일과 어떻게 자신만의 S3 클래스를 만들 수 있는지 배울 것입니다. 이 Section에서는, 베이스 R에서 사용되는 네 가지 중요한 S3 벡터들에 대해 논할 것입니다. 팩터(factor) 벡터에 기록된 정해진 레벨들의 후보에서 값이 비롯되는 범주형 데이터 날짜(Date) 벡터에 기록된 날짜들(요일 등까지도) POSIXct 벡터들에 저장된 날짜-시간들(초 아래 단위까지도) difftime 벡터에 저장된 지속기간들 3.4.1 Factors 팩터는 사전에 정의된 값들만을 가질 수 있는 벡터입니다. 이는 범주형 데이터를 저장하는 데에 사용됩니다. 팩터는 정수형 벡터에 두가지 속성이 더해져 만들어집니다. 일반적인 정수형 벡터들과 다르게 동작하게 해주는 “팩터” class와, 허용된 값들을 정의하는 levels가 그것입니다. x &lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;)) x #&gt; [1] a b b a #&gt; Levels: a b typeof(x) #&gt; [1] &quot;integer&quot; attributes(x) #&gt; $levels #&gt; [1] &quot;a&quot; &quot;b&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; 팩터는 가능한 값 세트를 알고 있지만, 그것들이 주어진 데이터셋이 전부 존재하지는 않을때 유용합니다. 문자형 벡터와는 다르게, 팩터를 표로 만들면 관찰되지 않은 값이라고 해도 모든 카테고리의 수를 얻을 수 있습니다. sex_char &lt;- c(&quot;m&quot;, &quot;m&quot;, &quot;m&quot;) sex_factor &lt;- factor(sex_char, levels = c(&quot;m&quot;, &quot;f&quot;)) table(sex_char) #&gt; sex_char #&gt; m #&gt; 3 table(sex_factor) #&gt; sex_factor #&gt; m f #&gt; 3 0 순서형(Ordered) 팩터는 팩터를 살짝 변형한 것입니다. 보통은 일반적인 팩터처럼 동작하지만, levels의 순서(low, medium, high)는 의미가 있습니다.(몇몇 모델이나 시각화 함수에서 자동으로 활용됩니다) grade &lt;- ordered(c(&quot;b&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;), levels = c(&quot;c&quot;, &quot;b&quot;, &quot;a&quot;)) grade #&gt; [1] b b a c #&gt; Levels: c &lt; b &lt; a Base R에서는 (read.csv(), data.frame()과 같은) 많은 기본 R 함수들이 자동으로 문자형 벡터들을 팩터로 바꿔버리기 때문에, 팩터를 매우 자주 접하게 됩니다. 하지만 이는 차선잭인데, 이러한 함수들이 모든 가능한 levels와 그들의 정확한 순서를 알 도리가 없기 때문입니다. levels는 데이터가 아닌 이론이나 실험 설계의 속성입니다. 대신에, stringAsFactors = FALSE 인자를 사용하면 이러한 현상을 제어할 수 있고, “이론적인” 데이터 지식을 활용해 손수 문자형 벡터들을 팩터로 바꿔줄 수 있습니다. 이에 대한 역사적 맥락을 더 배우고 싶다면, Roger Peng의 stringsAsFactors: An unauthorized biography와, Thomas Lumley의 stringsAsFactors = &lt;sigh&gt;를 추천합니다. 비록 팩터가 문자형 벡터처럼 생기고 동작하는 것처럼 보이지만, 정수형 벡터를 기반으로 한다는 것을 기억해야 합니다. 그러니까 이들을 문자열처럼 다룰 때는 주의하세요. gsub()나 grepl() 같은 몇몇 문자형 메소드들은 팩터를 문자열로 강제합니다. nchar()과 같은 애들은 에러를 내기도 하고, c() 같은 애들은 기저에 있는 정수형 벡터를 사용하기도 합니다. 이러한 이유로, 만약 문자열 같은 동작방식이 필요하다면, 명시적으로 팩터를 문자형 벡터로 바꿔 사용하는 것이 최선입니다. 3.4.2 Dates 날짜 벡터는 실수형(double) 벡터를 기반으로 만들어집니다. 이것들은 “Date” class 속성만을 가집니다. today &lt;- Sys.Date() typeof(today) #&gt; [1] &quot;double&quot; attributes(today) #&gt; $class #&gt; [1] &quot;Date&quot; 클래스를 제거하면 볼 수 있는 본래의 실수값은 1970-01-01로부터 흐른 날을 의미합니다. date &lt;- as.Date(&quot;1970-02-01&quot;) unclass(date) #&gt; [1] 31 3.4.3 Dates-times Base R은 날짜-시간 정보를 저장할 수 있는 두 방법을 제공합니다. POSIXct와 POSIXlt입니다. 넘나리 이상한 “POSIX”란 이름은 플랫폼 간 표준의 일원인 Portable Operating System Interface의 약자입니다. “ct”는 calendar time(C언어에서 time_t 타입)을, “lt”는 local time(C언어에서 struct tm 타입)을 의미합니다. 여기에서는 POSIXct에 초점을 맞춰보겠습니다. 왜냐하면 이것은 가장 간단하고, atomic vector를 기반으로 만들어졌으며, 데이터 프레임에서 사용하기에 가장 적절하기 때문입니다. POSIXct 벡터는 1970-01-01로부터 흐른 초 수를 표현한 실수값 위에 만들어졌습니다. now_ct &lt;- as.POSIXct(&quot;2018-08-01 22:00&quot;, tz = &quot;UTC&quot;) now_ct #&gt; [1] &quot;2018-08-01 22:00:00 UTC&quot; typeof(now_ct) #&gt; [1] &quot;double&quot; attributes(now_ct) #&gt; $class #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; #&gt; #&gt; $tzone #&gt; [1] &quot;UTC&quot; tzone 속성은 날짜-시간이 어떻게 포맷된 것인지를 제어합니다. 벡터에 의해 표현된 시간의 순간을 제어하진 않습니다. 자정이면 시간이 출력되지 않는다는 것은 알아두세요. structure(now_ct, tzone = &quot;Asia/Tokyo&quot;) #&gt; [1] &quot;2018-08-02 07:00:00 JST&quot; structure(now_ct, tzone = &quot;America/New_York&quot;) #&gt; [1] &quot;2018-08-01 18:00:00 EDT&quot; structure(now_ct, tzone = &quot;Australia/Lord_Howe&quot;) #&gt; [1] &quot;2018-08-02 08:30:00 +1030&quot; structure(now_ct, tzone = &quot;Europe/Paris&quot;) #&gt; [1] &quot;2018-08-02 CEST&quot; 3.4.4 Durations 날짜나 날짜-시간 데이터 쌍들 사이의 시간 간격을 의미하는 Durations는 시간차(difftimes) 안에 저장됩니다. Difftimes는 실수형 데이터로 구성되고, 정수가 어떻게 해석되어야 하는지 결정하는 units 속성을 가집니다. one_week_1 &lt;- as.difftime(1, units = &quot;weeks&quot;) one_week_1 #&gt; Time difference of 1 weeks typeof(one_week_1) #&gt; [1] &quot;double&quot; attributes(one_week_1) #&gt; $class #&gt; [1] &quot;difftime&quot; #&gt; #&gt; $units #&gt; [1] &quot;weeks&quot; one_week_2 &lt;- as.difftime(7, units = &quot;days&quot;) one_week_2 #&gt; Time difference of 7 days typeof(one_week_2) #&gt; [1] &quot;double&quot; attributes(one_week_2) #&gt; $class #&gt; [1] &quot;difftime&quot; #&gt; #&gt; $units #&gt; [1] &quot;days&quot; 3.4.5 Exercises table()은 어떤 종류의 객체를 반환합니까? 또한 무슨 타입이며, 어떤 속성들을 가집니까? 당신이 더 많은 변수를 표로 만들면 차원은 어떻게 변합니까? levels를 수정하면 팩터에 무슨 일이 발생합니까? f1 &lt;- factor(letters) levels(f1) &lt;- rev(levels(f1)) 이 코드는 무엇을 합니까? f2와 f3는 f1과 어떻게 다른가요? f2 &lt;- rev(factor(letters)) f3 &lt;- factor(letters, levels = rev(letters)) 3.5 Lists 3.6 Data frames and tibbles 3.7 NULL 3.8 Quiz answers 3.9 Summary 팩터 = 정수형 벡터 + &lt;factor class + levels&gt; "]
]
