[
<<<<<<< HEAD
["index.html", "Advanced R in Korean Preface", " Advanced R in Korean Jsang 2020-01-08 Preface 공부삼아 Wickham의 Advanced R을 번역하는 프로젝트를 시작했습니다. 경어체를 사용한 것은 순전히 본인의 취향입니다. 스스로 알아먹기 쉬운 느낌으로 의역을 잔뜩했습니다. 번역이 어려운 부분은 원문 그대로 남겼고, 용어는 한/영을 병기했습니다. (@ 블라블라) 형식으로 본인의 생각과 참견을 표현했습니다. "],
["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction 이 챕터는 패스하고 나중에 여유가 생기면 해보겠습니다. "],
["names-values.html", "Chapter 2 Names and values 2.1 Introduction 2.2 Binding basics 2.3 Copy-on-modify 2.4 Summary", " Chapter 2 Names and values 2.1 Introduction R에서는 객체(object)와 이름(name)의 차이를 이해하는 것이 중요합니다. 이를 이해하게 된다면, 더 정확하게 코드의 성능과 메모리 사용을 예측할 수 있습니다. 느린 코드의 주요 원인인 의도치 않은 복사를 피함으로써, 빠른 코드를 작성할 수 있습니다. R의 함수형 프로그래밍 툴에 대해 더욱 잘 이해할 수 있게 됩니다. 이 챕터의 목표는 이름(names)과 값(values) 의 차이, 그리고 언제 R이 객체(object)를 복사하는지 이해하도록 돕는 것입니다. Quiz 이 챕터를 넘겨도 될지 다음 문제를 통해 확인해보세요. 이 챕터 끝에 있는 Section 2.7에서 정답을 확인하실 수 있습니다. 주어진 데이터프레임에서, 어떻게 하면 1과 2의 합을 담고 있는 “3”이라는 컬럼을 만들 수 있을까요? [[는 사용하지 말고, $만 이용해보세요. 1, 2, 그리고 3을 변수명으로 사용하기 어렵게 만드는 것은 무엇인가요? df &lt;- data.frame(runif(3), runif(3)) names(df) &lt;- c(1, 2) 주어진 코드에서, y가 차지하는 메모리는 얼만큼인가요? x &lt;- runif(1e6) y &lt;- list(x, x, x) 주어진 예시에서 a가 복사되는 순간은 몇번째 줄일까요? a &lt;- c(1, 5, 3, 2) b &lt;- a b[[1]] &lt;- 10 Outline 섹션 2.2는 이름(names)와 값(values)의 차이점을 소개하고, &lt;-가 어떻게 이름과 값 사이의 연결(binding)이나 참조(reference)를 만들어내는지 다룹니다. 섹션 2.3은 R이 언제 ’복사’를 실행하는지 설명합니다. 벡터를 변형시킬때라면, 거의 대부분 새로운 변형된 벡터를 생성하는 것이라 볼 수 있습니다. tracemem() 을 사용해 언제 복사가 실제로 일어나는지 확인하는 법을 배웁니다. 그리고나면 이것들이 함수 실행, 리스트, 데이터프레임, 그리고 문자형 벡터들에 어떤 식으로 적용되는지 살펴볼 것입니다. 섹션 2.4에서는 객체(object)가 얼마나 메모리를 차지하는지에 대해, 이전 두 섹터가 갖는 함의를 탐험하게 될 것입니다. 이에 대한 당신의 직관이 아마 꽤나 잘못되어 있을 것이고, 안타깝게도 utils::object.size()가 부정확하기에, lobstr::obj_size()를 사용하는 법을 배울 것입니다. 섹션 2.5에선 ‘copy-on-modify’(@ 후에 보다 자세히 다루겠지만 ‘변형을 할 때 복사가 일어난다’ 정도로 이해하면 될 것 같습니다)의 중요한 두가지 예외를 알아볼 것입니다. 환경(environments)과 하나의 이름을 갖는 값에 대해서, 객체는 place에서 변형됩니다.(@ 추후 보충할 것) 섹션 2.6에서는 더이상 이름으로 참조되지 않는 객체에 의해 사용되는 메모리를 비워주는, garbage collector에 대해 살펴보면서 챕터를 마치겠습니다. Prerequisites 우린 R 객체의 내부적 표현법을 자세히 살펴보기 위해 lobstr 패키지를 사용할 것입니다. library(lobstr) 2.2 Binding basics 이 코드를 한 번 봅시다. x &lt;- c(1, 2, 3) 이 코드는 \" x라는 이름으로, 1, 2, 3을 포함하는 객체를 만들어라. \" 라는 식으로 해석하기 쉽습니다. 만약 이런 식으로 이해한다면, 아쉽게도 R이 수면 아래에서 실제로 어떤식으로 동작하는지에 대해 부정확하게 예측하게 됩니다. 위의 해석보다는 아래의 두가지 액션을 취한다고 말하는 것이 보다 정확합니다. c(1, 2, 3)이라는 값들의 벡터인 객체를 만듭니다. 그리고 이 객체를 x라고 하는 이름과 연결시킵니다. 즉, 객체나 값은 이름을 갖는 것이 아닙니다. 실제론 이름이 값을 갖는 것입니다. 이 차이를 명확히 하기 위해, 그림을 하나 그려보겠습니다. x라고 하는 이름은, 둥근 모서리로 된 사각형으로 표현되고 있습니다. 그리고 얘는 벡터 c(1, 2, 3)이라는 값을 가리키는(또는 묶어주는, 또는 참조하는) 화살표를 갖고 있습니다. 이 화살표는 할당 연산자인 &lt;-와는 반대 방향을 가리키고 있는데, &lt;-는 왼쪽에 있는 이름을 오른쪽에 있는 객체로 묶어(binding)줍니다. 다시 말해, 이름(name)을 값(value)에 대한 참조(reference)로 생각해도 무방합니다.(@ 참조라는 말이 잘 와닿진 않는데 ‘주소’ 정도로 이해해도 괜찮으려나?) 예를 들어, 아래 코드를 실행하면 c(1, 2, 3)을 복사하지 않습니다. 그저 이미 존재하고 있던 객체에 대한 다른 ’주소’가 생겨날 뿐입니다.(@ 실존하는 하나의 집을, 여러 종류의 주소로 표현할 수 있는 것과 비슷한 느낌) y &lt;- x 아마 c(1, 2, 3)에 0x74b라는 라벨이 붙어있는 것을 발견하셨을 겁니다. 벡터가 이름을 갖진 않지만, 바인딩과는 독립적으로 객체를 참조해야 할 때가 있습니다. 이를 위해, 값에 고유한 식별자(ID)를 부여한 것입니다. 이 ID는 객체의 메모리 ’주소’처럼 생긴 특별한 형식을 가지고 있습니다. 주소라함은 객체가 저장된 메모리의 위치이기 때문입니다. 하지만 실제 메모리 주소는 코드를 실행할 때마다 변하기 때문에, 대신 ID를 사용하기로 합니다. lobstr::obj_addr()을 이용해 객체의 ID에 접근할 수 있습니다. 실제로 사용해보면 x와 y가 같은 ID를 가리키고 있음을 볼 수 있습니다. obj_addr(x) #&gt; [1] &quot;0x15f44208&quot; obj_addr(y) #&gt; [1] &quot;0x15f44208&quot; 이 ID들은 길고 R을 재시작할 때마다 바뀝니다. 이름과 값의 차이를 이해하는 데에는 시간이 좀 걸릴 겁니다. 하지만 이해하고나면, 함수형 프로그래밍에 있어 크게 도움이 됩니다. 다른 맥락에서 다른 이름을 가지는 함수들에 대해서 말이죠. 2.2.1 Non-syntactic names R은 유효한 이름에 대해 엄격한 기준을 갖고 있습니다. 문법적으로 올바른(syntactic) 이름은 반드시 글자, 숫자, ., 그리고 _로 이루어져야 하며, _나 숫자로 시작할 수 없습니다. 또한 TRUE, NULL, if, 그리고 function과 같은 예약어(reserved words)는 사용할 수 없습니다.(@ 예약어는 R에서 이미 사용되고 있는 단어들이라고 볼 수 있겠습니다) 이 규칙들을 따르지 않는 이름을 non-syntactic한 이름이라고 하며, 만약 이를 사용하려고 하면 에러가 납니다. _abc &lt;- 1 #&gt; Error: unexpected input in &quot;_&quot; if &lt;- 10 #&gt; Error: unexpected assignment in &quot;if &lt;-&quot; 이 규칙들을 어기고 어떤 이름이든 사용하는 것도 가능은 합니다. 어떤 종류의 문자열이든 backticks로 감싸주면 됩니다. `_abc` &lt;- 1 `_abc` #&gt; [1] 1 `if` &lt;- 10 `if` #&gt; [1] 10 보통 의도적으로 이런 요상한 이름들을 만들 일은 거의 없겠지만, R 외부에서 만들어진 데이터를 불러올 때 이런 이름들을 흔히 마주칠 수 있기 때문에, 이를 이해할 필요가 있습니다. 2.2.2 Exercises a, b, c, d의 관계를 설명해보세요. a &lt;- 1:10 b &lt;- a c &lt;- b d &lt;- 1:10 아래 코드는 평균 함수에 여러 방식으로 접근하고 있습니다. 이들은 전부 동일한 함수 객체를 가르키고 있는 것일까요? lobstr::obj_addr()을 이용해 확인해보세요. mean base::mean get(&quot;mean&quot;) evalq(mean) match.fun(&quot;mean&quot;) 디폴트로, read.csv 같은 R의 기본 데이터 불러오기 함수는, 자동으로 non-syntactic한 이름들을 syntactic하게 바꿉니다. 이게 왜 문제가 될 수 있을까요? 이런 행태를 억제할 수 있게 해주는 옵션은 무엇인가요? non-syntactic한 이름을 syntactic하게 변환하기 위해 make.names()가 사용하는 규칙은 무엇입니까? 저는 syntactic한 이름을 결정짓는 규칙을 조금 단순화해서 설명했습니다. 왜 .123e1은 syntactic한 이름이 아닐까요? 자세히 알기 위해 ?makes.names를 읽어보세요. 2.3 Copy-on-modify 아래 코드를 살펴봅시다. 이것은 x와 y를 동일한 수면 밑 값과 묶어줍니다. 그리고 y를 변형합니다. x &lt;- c(1, 2, 3) y &lt;- x y[[3]] &lt;- 4 x #&gt; [1] 1 2 3 y를 변형하는 것은 분명히 x는 변형시키지 않습니다. 그럼 공유된 연결성에는 무슨 일이 일어날까요? y와 연관된 값은 변하지만, 원본 객체는 그렇지 않습니다. 대신에, R은 0x74b의 값을 하나 바꾼 0xcd2라는 새로운 복사본을 만들고, y와 다시 연결시켜 줍니다. 이런 현상을 copy-on-modify라고 부릅니다. 이를 이해한다면 R 코드 성능에 대한 직관이 굉장히 향상될 것입니다. 이 행태를 설명하는 다른 표현으로, R 객체는 변경할 수 없다(unchangeable), 또는 불변하다(immutable) 등이 있겠습니다. 그러나 전 이런 용어는 대체로 쓰지 않으려고 하는데, 섹션 2.5에서 배우게 될 copy-on-modify의 중요한 예외사항들이 있기 때문입니다. copy-on-modify에 대해 탐험하려고 할 때, RStudio 내에서는 다른 결과들을 얻게 될 수 있다는 것에 유의하세요. 이건 환경창(environment pane)이 각 객체들에 대한 정보를 보여주기 위해, 각 객체에 대한 참조를 만들어야만 하기 때문입니다. 이는 당신의 인터엑티브한 탐험을 왜곡시킬 수 있지만, 함수 내부에 있는 코드들엔 영향을 미치지 않습니다. 때문에 데이터 분석을 하는 동안에는 성능에 영향도 없습니다. 실험을 위해서라면, 터미널에서 R을 직접 실행하거나, RMarkdown을 이용하는 것을 추천드립니다. 2.3.1 tracemem() base::tracemem()의 도움을 받아 객체가 언제 복사되는지 볼 수 있습니다. 한 번 이 함수를 어떤 객체로 실행하면, 이 갳체의 최근 주소를 받아볼 수 있습니다. x &lt;- c(1, 2, 3) cat(tracemem(x), &quot;\\n&quot;) #&gt; &lt;0x7f80c0e0ffc8&gt; 함수를 실행하고나서 객체가 복사될 때마다 tracemem()이 복사된 객체, 그것의 새 주소와 복사를 일으킨 호출 순서를 알려줄 것입니다. y &lt;- x y[[3]] &lt;- 4L #&gt; tracemem[0x7f80c0e0ffc8 -&gt; 0x7f80c4427f40]: 만약 y를 다시 변경하면, 복사는 일어나지 않습니다. 이는 새로운 객체가 이제 오직 하나의 이름에 연결되어 있기에, R이 modify-in-place를 적용하기 때문입니다. 이것에 대해선 섹션 2.5에서 다시 알아봅시다. y[[3]] &lt;- 5L untracemem(x) untracemem()은 tracemem()과 반대로, 추적을 종료해줍니다. 2.3.2 Function calls 함수를 호출할 때에도 동일한 복사 규칙이 적용됩니다. 코드를 봅시다. f &lt;- function(a) { a } x &lt;- c(1, 2, 3) cat(tracemem(x), &quot;\\n&quot;) #&gt; &lt;00000000191490C0&gt; z &lt;- f(x) # there&#39;s no copy here! untracemem(x) f()이 실행되는 동안, 함수 내부의 a는 함수 외부의 x와 같은 값을 가리키게 됩니다. 그림에서 나타난 표현법에 대해서는 섹션 7.4.4에서 더 배우게 될 것입니다. 간략히 설명하자면, 함수 f()는 오른편 노란색 객체로 표현되었습니다. 이 함수의 argument인 a는 함수가 실행될 때, 실행 환경(회색 박스)에서 바인딩(검은 점선)이 됩니다. f()가 완료되면, x와 z는 같은 객체를 가리키게 됩니다. 0x74b는 한 번도 복사되지 않았는데, 변형된 적이 없기 때문입니다. 만약 f()가 x를 변형시키는 함수였다면, R는 새로운 복사본을 만들었을 것이고, 그리고 나서 z가 그 객체와 연결되었을 겁니다. 2.3.3 Lists 값을 가리키는 것은 이름(즉, 변수)만이 아닙니다. 리스트의 원소 역시 동일한 역할을 합니다. 이 리스트는 표면적으로 봤을 때, 위에 나왔던 숫자형 벡터와 매우 비슷합니다. l1 &lt;- list(1, 2, 3) 이 리스트는 사실 벡터보단 더 복잡한데, 값 자체를 저장하는 것이 아니라, 값에 대한 참조값들(주소들)을 저장하기 때문입니다. 이 사실은 리스트를 변형하려 할 때 특히 중요하게 작용합니다. l2 &lt;- l1 l2[[3]] &lt;- 4 벡터와 마찬가지로, 리스트도 copy-on-modify 성질을 사용합니다. 원본 리스트는 변하지 않은채 남겨져 있고, 변형된 새 복사본을 만들어 냅니다. 하지만 이는 얕은 복사입니다. 얕은이라고 표현한 것은, 리스트 객체와 해당 바인딩들은 복사되지만, 바인딩이 가리키고 있는 값들은 복사되지 않기 때문입니다. 얕은 복사의 반대는 깊은 복사인데, 이는 모든 참조값들이 복사됩니다. R 3.1.0 버전 이전에는 모든 복사가 깊은 복사였습니다. 리스트들 간에 공유되는 값들을 보려면, lobstr::ref()를 사용하면 됩니다. ref()는 각 객체의 메모리 주소를 로컬 ID와 함께 출력해주기 때문에, 공유된 요소들을 쉽게 상호 참조할 수 있습니다. ref(l1, l2) #&gt; o [1:0x19a6f4a8] &lt;list&gt; #&gt; +-[2:0x19a3d1c0] &lt;dbl&gt; #&gt; +-[3:0x19a3d188] &lt;dbl&gt; #&gt; \\-[4:0x19a3d150] &lt;dbl&gt; #&gt; #&gt; o [5:0x1a3a3538] &lt;list&gt; #&gt; +-[2:0x19a3d1c0] #&gt; +-[3:0x19a3d188] #&gt; \\-[6:0x1a37c500] &lt;dbl&gt; 2.3.4 Data frames 데이터프레임은 벡터들의 리스트입니다. 때문에 데이터프레임을 변형할 때도 copy-on-modify가 중요한 결과를 불러옵니다. 예시로 이 데이터프레임을 봅시다. d1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3)) 만약 열을 변형한다면, 오직 해당 열만 변형되면 됩니다. 다른 열들은 그대로 원래 참조값들을 가리키면 되는 것입니다. d2 &lt;- d1 d2[, 2] &lt;- d2[, 2] * 2 하지만 만약 행을 변형한다면, 모든 열이 바뀝니다. 다시 말해 모든 열이 복사되어야 합니다. d3 &lt;- d1 d3[1, ] &lt;- d3[1, ] * 3 2.3.5 Character vectors R이 참조를 사용하는 마지막 장소는 바로 문자형 벡터입니다. 전 보통 문자형 벡터들을 이런 식으로 표현합니다. x &lt;- c(&quot;a&quot;, &quot;a&quot;, &quot;abc&quot;, &quot;d&quot;) 하지만 이건 좀 예의바른 예시입니다. R은 실제로 global string pool을 이용하는데, 문자형 벡터의 각 요소들이 고유한 문자 풀에 대한 포인터가 됩니다. ref()의 character 변수를 TRUE로 세팅하면 이 참조값들을 볼 수 있습니다. ref(x, character = TRUE) #&gt; o [1:0x189d22a0] &lt;chr&gt; #&gt; +-[2:0x12f37598] &lt;string: &quot;a&quot;&gt; #&gt; +-[2:0x12f37598] #&gt; +-[3:0x180ca668] &lt;string: &quot;abc&quot;&gt; #&gt; \\-[4:0x13135230] &lt;string: &quot;d&quot;&gt; 이는 문자형 벡터가 차지하는 메모리 사용량에 큰 영향을 미치는데, 일반적으로 그리 중요하진 않으므로, 책의 다른 부분에서는 문자열이 벡터 내부에 있는 것처럼 문자형 벡터를 표현할 것입니다. 2.3.6 Exercises 왜 tracemem(1:10)은 별로 쓸모가 없습니까? 이 코드를 실행했을 때, 왜 tracemem()이 복사를 두번 보여주는지 설명해보세요. 힌트: 이 코드와 이전 내용에서 등장했던 코드의 차이점을 유심히 살펴보세요. x &lt;- c(1L, 2L, 3L) tracemem(x) x[[3]] &lt;- 4 주어진 객체들간의 관계를 그려보세요. a &lt;- 1:10 b &lt;- list(a, a) c &lt;- list(b, a, 1:10) 이 코드를 실행하면 무슨 일이 일어날까요? x &lt;- list(1:10) x[[2]] &lt;- x 그림을 그려보세요. 2.4 Summary "]
=======
["index.html", "Advanced R in Korean Preface", " Advanced R in Korean Jsang 2020-01-04 Preface 공부삼아 Wickham의 Advanced R을 번역하는 프로젝트를 시작했습니다. 경어체를 사용한 것은 순전히 본인의 취향입니다. 스스로 알아먹기 쉬운 느낌으로 의역을 잔뜩했습니다. 번역이 어려운 부분은 원문 그대로 남겼고, 용어는 한/영을 병기했습니다. (@ 블라블라) 형식으로 본인의 생각과 참견을 표현했습니다. "],
["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction 이 챕터는 패스하고 나중에 여유가 생기면 해보겠습니다. "],
["names-values.html", "Chapter 2 Names and values 2.1 Introduction 2.2 Binding basics 2.3 Copy-on-modify", " Chapter 2 Names and values 2.1 Introduction R에서는 객체(object)와 이름(name)의 차이를 이해하는 것이 중요합니다. 이를 이해하게 된다면, 더 정확하게 코드의 성능과 메모리 사용을 예측할 수 있습니다. 느린 코드의 주요 원인인 의도치 않은 복사를 피함으로써, 빠른 코드를 작성할 수 있습니다. R의 함수형 프로그래밍 툴에 대해 더욱 잘 이해할 수 있게 됩니다. 이 챕터의 목표는 이름(names)과 값(values) 의 차이, 그리고 언제 R이 객체(object)를 복사하는지 이해하도록 돕는 것입니다. Quiz 이 챕터를 넘겨도 될지 다음 문제를 통해 확인해보세요. 이 챕터 끝에 있는 Section 2.7에서 정답을 확인하실 수 있습니다. 주어진 데이터프레임에서, 어떻게 하면 1과 2의 합을 담고 있는 “3”이라는 컬럼을 만들 수 있을까요? [[는 사용하지 말고, $만 이용해보세요. 1, 2, 그리고 3을 변수명으로 사용하기 어렵게 만드는 것은 무엇인가요? df &lt;- data.frame(runif(3), runif(3)) names(df) &lt;- c(1, 2) 주어진 코드에서, y가 차지하는 메모리는 얼만큼인가요? x &lt;- runif(1e6) y &lt;- list(x, x, x) 주어진 예시에서 a가 복사되는 순간은 몇번째 줄일까요? a &lt;- c(1, 5, 3, 2) b &lt;- a b[[1]] &lt;- 10 Outline 섹션 2.2는 이름(names)와 값(values)의 차이점을 소개하고, &lt;-가 어떻게 이름과 값 사이의 연결(binding)이나 참조(reference)를 만들어내는지 다룹니다. 섹션 2.3은 R이 언제 ’복사’를 실행하는지 설명합니다. 벡터를 변형시킬때라면, 거의 대부분 새로운 변형된 벡터를 생성하는 것이라 볼 수 있습니다. tracemem() 을 사용해 언제 복사가 실제로 일어나는지 확인하는 법을 배웁니다. 그리고나면 이것들이 함수 실행, 리스트, 데이터프레임, 그리고 문자형 벡터들에 어떤 식으로 적용되는지 살펴볼 것입니다. 섹션 2.4에서는 객체(object)가 얼마나 메모리를 차지하는지에 대해, 이전 두 섹터가 갖는 함의를 탐험하게 될 것입니다. 이에 대한 당신의 직관이 아마 꽤나 잘못되어 있을 것이고, 안타깝게도 utils::object.size()가 부정확하기에, lobstr::obj_size()를 사용하는 법을 배울 것입니다. 섹션 2.5에선 ‘copy-on-modify’(@ 후에 보다 자세히 다루겠지만 ‘변형을 할 때 복사가 일어난다’ 정도로 이해하면 될 것 같습니다)의 중요한 두가지 예외를 알아볼 것입니다. 환경(environments)과 하나의 이름을 갖는 값에 대해서, 객체는 place에서 변형됩니다.(@ 추후 보충할 것) 섹션 2.6에서는 더이상 이름으로 참조되지 않는 객체에 의해 사용되는 메모리를 비워주는, garbage collector에 대해 살펴보면서 챕터를 마치겠습니다. Prerequisites 우린 R 객체의 내부적 표현법을 자세히 살펴보기 위해 lobstr 패키지를 사용할 것입니다. library(lobstr) 2.2 Binding basics 이 코드를 한 번 봅시다. x &lt;- c(1, 2, 3) 이 코드는 \" x라는 이름으로, 1, 2, 3을 포함하는 객체를 만들어라. \" 라는 식으로 해석하기 쉽습니다. 만약 이런 식으로 이해한다면, 아쉽게도 R이 수면 아래에서 실제로 어떤식으로 동작하는지에 대해 부정확하게 예측하게 됩니다. 위의 해석보다는 아래의 두가지 액션을 취한다고 말하는 것이 보다 정확합니다. c(1, 2, 3)이라는 값들의 벡터인 객체를 만듭니다. 그리고 이 객체를 x라고 하는 이름과 연결시킵니다. 즉, 객체나 값은 이름을 갖는 것이 아닙니다. 실제론 이름이 값을 갖는 것입니다. 이 차이를 명확히 하기 위해, 그림을 하나 그려보겠습니다. x라고 하는 이름은, 둥근 모서리로 된 사각형으로 표현되고 있습니다. 그리고 얘는 벡터 c(1, 2, 3)이라는 값을 가리키는(또는 묶어주는, 또는 참조하는) 화살표를 갖고 있습니다. 이 화살표는 할당 연산자인 &lt;-와는 반대 방향을 가리키고 있는데, &lt;-는 왼쪽에 있는 이름을 오른쪽에 있는 객체로 묶어(binding)줍니다. 다시 말해, 이름(name)을 값(value)에 대한 참조(reference)로 생각해도 무방합니다.(@ 참조라는 말이 잘 와닿진 않는데 ‘주소’ 정도로 이해해도 괜찮으려나?) 예를 들어, 아래 코드를 실행하면 c(1, 2, 3)을 복사하지 않습니다. 그저 이미 존재하고 있던 객체에 대한 다른 ’주소’가 생겨날 뿐입니다.(@ 실존하는 하나의 집을, 여러 종류의 주소로 표현할 수 있는 것과 비슷한 느낌) y &lt;- x 아마 c(1, 2, 3)에 0x74b라는 라벨이 붙어있는 것을 발견하셨을 겁니다. 벡터가 이름을 갖진 않지만, 바인딩과는 독립적으로 객체를 참조해야 할 때가 있습니다. 이를 위해, 값에 고유한 식별자(ID)를 부여한 것입니다. 이 ID는 객체의 메모리 ’주소’처럼 생긴 특별한 형식을 가지고 있습니다. 주소라함은 객체가 저장된 메모리의 위치이기 때문입니다. 하지만 실제 메모리 주소는 코드를 실행할 때마다 변하기 때문에, 대신 ID를 사용하기로 합니다. lobstr::obj_addr()을 이용해 객체의 ID에 접근할 수 있습니다. 실제로 사용해보면 x와 y가 같은 ID를 가리키고 있음을 볼 수 있습니다. obj_addr(x) #&gt; [1] &quot;0x15f44208&quot; obj_addr(y) #&gt; [1] &quot;0x15f44208&quot; 이 ID들은 길고 R을 재시작할 때마다 바뀝니다. 이름과 값의 차이를 이해하는 데에는 시간이 좀 걸릴 겁니다. 하지만 이해하고나면, 함수형 프로그래밍에 있어 크게 도움이 됩니다. 다른 맥락에서 다른 이름을 가지는 함수들에 대해서 말이죠. 2.2.1 Non-syntactic names R은 유효한 이름에 대해 엄격한 기준을 갖고 있습니다. 문법적으로 올바른(syntactic) 이름은 반드시 글자, 숫자, ., 그리고 _로 이루어져야 하며, _나 숫자로 시작할 수 없습니다. 또한 TRUE, NULL, if, 그리고 function과 같은 예약어(reserved words)는 사용할 수 없습니다.(@ 예약어는 R에서 이미 사용되고 있는 단어들이라고 볼 수 있겠습니다) 이 규칙들을 따르지 않는 이름을 non-syntactic한 이름이라고 하며, 만약 이를 사용하려고 하면 에러가 납니다. _abc &lt;- 1 #&gt; Error: unexpected input in &quot;_&quot; if &lt;- 10 #&gt; Error: unexpected assignment in &quot;if &lt;-&quot; 이 규칙들을 어기고 어떤 이름이든 사용하는 것도 가능은 합니다. 어떤 종류의 문자열이든 backticks로 감싸주면 됩니다. `_abc` &lt;- 1 `_abc` #&gt; [1] 1 `if` &lt;- 10 `if` #&gt; [1] 10 보통 의도적으로 이런 요상한 이름들을 만들 일은 거의 없겠지만, R 외부에서 만들어진 데이터를 불러올 때 이런 이름들을 흔히 마주칠 수 있기 때문에, 이를 이해할 필요가 있습니다. 2.2.2 Exercises a, b, c, d의 관계를 설명해보세요. a &lt;- 1:10 b &lt;- a c &lt;- b d &lt;- 1:10 아래 코드는 평균 함수에 여러 방식으로 접근하고 있습니다. 이들은 전부 동일한 함수 객체를 가르키고 있는 것일까요? lobstr::obj_addr()을 이용해 확인해보세요. mean base::mean get(&quot;mean&quot;) evalq(mean) match.fun(&quot;mean&quot;) 디폴트로, read.csv 같은 R의 기본 데이터 불러오기 함수는, 자동으로 non-syntactic한 이름들을 syntactic하게 바꿉니다. 이게 왜 문제가 될 수 있을까요? 이런 행태를 억제할 수 있게 해주는 옵션은 무엇인가요? non-syntactic한 이름을 syntactic하게 변환하기 위해 make.names()가 사용하는 규칙은 무엇입니까? 저는 syntactic한 이름을 결정짓는 규칙을 조금 단순화해서 설명했습니다. 왜 .123e1은 syntactic한 이름이 아닐까요? 자세히 알기 위해 ?makes.names를 읽어보세요. 2.3 Copy-on-modify 아래 코드를 살펴봅시다. 이것은 x와 y를 동일한 수면 밑 값과 묶어줍니다. 그리고 y를 변형합니다. x &lt;- c(1, 2, 3) y &lt;- x y[[3]] &lt;- 4 x #&gt; [1] 1 2 3 y를 변형하는 것은 분명히 x는 변형시키지 않습니다. 그럼 공유된 연결성에는 무슨 일이 일어날까요? y와 연관된 값은 변하지만, 원본 객체는 그렇지 않습니다. 대신에, R은 0x74b의 값을 하나 바꾼 0xcd2라는 새로운 복사본을 만들고, y와 다시 연결시켜 줍니다. 이런 현상을 copy-on-modify라고 부릅니다. 이를 이해한다면 R 코드 성능에 대한 직관이 굉장히 향상될 것입니다. 이 행태를 설명하는 다른 표현으로, R 객체는 변경할 수 없다(unchangeable), 또는 불변하다(immutable) 등이 있겠습니다. 그러나 전 이런 용어는 대체로 쓰지 않으려고 하는데, 섹션 2.5에서 배우게 될 copy-on-modify의 중요한 예외사항들이 있기 때문입니다. copy-on-modify에 대해 탐험하려고 할 때, RStudio 내에서는 다른 결과들을 얻게 될 수 있다는 것에 유의하세요. 이건 환경창(environment pane)이 각 객체들에 대한 정보를 보여주기 위해, 각 객체에 대한 참조를 만들어야만 하기 때문입니다. 이는 당신의 인터엑티브한 탐험을 왜곡시킬 수 있지만, 함수 내부에 있는 코드들엔 영향을 미치지 않습니다. 때문에 데이터 분석을 하는 동안에는 성능에 영향도 없습니다. 실험을 위해서라면, 터미널에서 R을 직접 실행하거나, RMarkdown을 이용하는 것을 추천드립니다. 2.3.1 tracemem() 2.3.2 Function calls 2.3.3 Lists 2.3.4 Data frames 2.3.5 Character vectors 2.3.6 Exercises "]
>>>>>>> 73a89cbaf567c6ff4a06ff5cd92186f99b08609f
]
