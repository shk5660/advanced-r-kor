# Names and values {#names-values}




## Introduction

R에서는 객체(object)와 이름(name)의 차이를 이해하는 것이 중요합니다. 이를 이해하게 된다면,

* 더 정확하게 코드의 성능과 메모리 사용을 예측할 수 있습니다.
* 느린 코드의 주요 원인인 의도치 않은 복사를 피함으로써, 빠른 코드를 작성할 수 있습니다.
* R의 함수형 프로그래밍 툴에 대해 더욱 잘 이해할 수 있게 됩니다.

이 챕터의 목표는 이름(names)과 값(values) 의 차이, 그리고 언제 R이 객체(object)를 복사하는지 이해하도록 돕는 것입니다.


### Quiz {-}

이 챕터를 넘겨도 될지 다음 문제를 통해 확인해보세요. 이 챕터 끝에 있는 Section 2.7에서 정답을 확인하실 수 있습니다.

1. 주어진 데이터프레임에서, 어떻게 하면 `1`과 `2`의 합을 담고 있는 "3"이라는 컬럼을 만들 수 있을까요? `[[`는 사용하지 말고, `$`만 이용해보세요. `1`, `2`, 그리고 `3`을 변수명으로 사용하기 어렵게 만드는 것은 무엇인가요?


```r
df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)
```

2. 주어진 코드에서, `y`가 차지하는 메모리는 얼만큼인가요?


```r
x <- runif(1e6)
y <- list(x, x, x)
```

3. 주어진 예시에서 `a`가 복사되는 순간은 몇번째 줄일까요?


```r
a <- c(1, 5, 3, 2)
b <- a
b[[1]] <- 10
```


### Outline {-}

* 섹션 2.2는 이름(names)와 값(values)의 차이점을 소개하고, `<-`가 어떻게 이름과 값 사이의 연결(binding)이나 참조(reference)를 만들어내는지 다룹니다.

* 섹션 2.3은 R이 언제 '복사'를 실행하는지 설명합니다. 벡터를 변형시킬때라면, 거의 대부분 새로운 변형된 벡터를 생성하는 것이라 볼 수 있습니다. `tracemem()` 을 사용해 언제 복사가 실제로 일어나는지 확인하는 법을 배웁니다. 그리고나면 이것들이 함수 실행, 리스트, 데이터프레임, 그리고 문자형 벡터들에 어떤 식으로 적용되는지 살펴볼 것입니다.

* 섹션 2.4에서는 객체(object)가 얼마나 메모리를 차지하는지에 대해, 이전 두 섹터가 갖는 함의를 탐험하게 될 것입니다. 이에 대한 당신의 직관이 아마 꽤나 잘못되어 있을 것이고, 안타깝게도 `utils::object.size()`가 부정확하기에, `lobstr::obj_size()`를 사용하는 법을 배울 것입니다.

* 섹션 2.5에선 'copy-on-modify'(* 후에 보다 자세히 다루겠지만 '변형을 할 때 복사가 일어난다' 정도로 이해하면 될 것 같습니다)의 중요한 두가지 예외를 알아볼 것입니다. 환경(environments)과 하나의 이름을 갖는 값에 대해서, 객체는 place에서 변형됩니다.(* 추후 보충할 것)

* 섹션 2.6에서는 더이상 이름으로 참조되지 않는 객체에 의해 사용되는 메모리를 비워주는, garbage collector에 대해 살펴보면서 챕터를 마치겠습니다.


### Prerequisites {-}

우린 R 객체의 내부적 표현법을 자세히 살펴보기 위해 [lobstr](https://github.com/r-lib/lobstr) 패키지를 사용할 것입니다.


```r
library(lobstr)
#> Warning: 패키지 'lobstr'는 R 버전 3.6.2에서 작성되었습니다
```


## Binding basics

이 코드를 한 번 봅시다.


```r
x <- c(1, 2, 3)
```

이 코드는 *" x라는 이름으로, 1, 2, 3을 포함하는 객체를 만들어라. "* 라는 식으로 해석하기 쉽습니다. 











