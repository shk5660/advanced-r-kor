<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 3 Vectors | Advanced R in Korean</title>
  <meta name="description" content="Everything you need (and nothing more) to start a bookdown book." />
  <meta name="generator" content="bookdown 0.16 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 3 Vectors | Advanced R in Korean" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="http://seankross.com/bookdown-start/" />
  
  <meta property="og:description" content="Everything you need (and nothing more) to start a bookdown book." />
  <meta name="github-repo" content="shk5660/advanced-r-kor" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 3 Vectors | Advanced R in Korean" />
  
  <meta name="twitter:description" content="Everything you need (and nothing more) to start a bookdown book." />
  

<meta name="author" content="Jsang" />


<meta name="date" content="2020-02-20" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="names-values.html"/>

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Advanced R in Korean</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="chapter" data-level="1" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a></li>
<li class="chapter" data-level="2" data-path="names-values.html"><a href="names-values.html"><i class="fa fa-check"></i><b>2</b> Names and values</a><ul>
<li class="chapter" data-level="2.1" data-path="names-values.html"><a href="names-values.html#introduction-1"><i class="fa fa-check"></i><b>2.1</b> Introduction</a><ul>
<li class="chapter" data-level="" data-path="names-values.html"><a href="names-values.html#quiz"><i class="fa fa-check"></i>Quiz</a></li>
<li class="chapter" data-level="" data-path="names-values.html"><a href="names-values.html#outline"><i class="fa fa-check"></i>Outline</a></li>
<li class="chapter" data-level="" data-path="names-values.html"><a href="names-values.html#prerequisites"><i class="fa fa-check"></i>Prerequisites</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="names-values.html"><a href="names-values.html#binding-basics"><i class="fa fa-check"></i><b>2.2</b> Binding basics</a><ul>
<li class="chapter" data-level="2.2.1" data-path="names-values.html"><a href="names-values.html#non-syntactic"><i class="fa fa-check"></i><b>2.2.1</b> Non-syntactic names</a></li>
<li class="chapter" data-level="2.2.2" data-path="names-values.html"><a href="names-values.html#exercises"><i class="fa fa-check"></i><b>2.2.2</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="names-values.html"><a href="names-values.html#copy-on-modify"><i class="fa fa-check"></i><b>2.3</b> Copy-on-modify</a><ul>
<li class="chapter" data-level="2.3.1" data-path="names-values.html"><a href="names-values.html#tracemem"><i class="fa fa-check"></i><b>2.3.1</b> <code>tracemem()</code></a></li>
<li class="chapter" data-level="2.3.2" data-path="names-values.html"><a href="names-values.html#function-calls"><i class="fa fa-check"></i><b>2.3.2</b> Function calls</a></li>
<li class="chapter" data-level="2.3.3" data-path="names-values.html"><a href="names-values.html#lists"><i class="fa fa-check"></i><b>2.3.3</b> Lists</a></li>
<li class="chapter" data-level="2.3.4" data-path="names-values.html"><a href="names-values.html#data-frames"><i class="fa fa-check"></i><b>2.3.4</b> Data frames</a></li>
<li class="chapter" data-level="2.3.5" data-path="names-values.html"><a href="names-values.html#character-vectors"><i class="fa fa-check"></i><b>2.3.5</b> Character vectors</a></li>
<li class="chapter" data-level="2.3.6" data-path="names-values.html"><a href="names-values.html#exercises-1"><i class="fa fa-check"></i><b>2.3.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="names-values.html"><a href="names-values.html#object-size"><i class="fa fa-check"></i><b>2.4</b> Object size</a><ul>
<li class="chapter" data-level="2.4.1" data-path="names-values.html"><a href="names-values.html#exercises-2"><i class="fa fa-check"></i><b>2.4.1</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="names-values.html"><a href="names-values.html#modify-in-place"><i class="fa fa-check"></i><b>2.5</b> Modify-in-place</a><ul>
<li class="chapter" data-level="2.5.1" data-path="names-values.html"><a href="names-values.html#objects-with-a-single-binding"><i class="fa fa-check"></i><b>2.5.1</b> Objects with a single binding</a></li>
<li class="chapter" data-level="2.5.2" data-path="names-values.html"><a href="names-values.html#environments"><i class="fa fa-check"></i><b>2.5.2</b> Environments</a></li>
<li class="chapter" data-level="2.5.3" data-path="names-values.html"><a href="names-values.html#exercises-3"><i class="fa fa-check"></i><b>2.5.3</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="names-values.html"><a href="names-values.html#unbinding-and-the-garbage-collector"><i class="fa fa-check"></i><b>2.6</b> Unbinding and the garbage collector</a></li>
<li class="chapter" data-level="2.7" data-path="names-values.html"><a href="names-values.html#quiz-answers"><i class="fa fa-check"></i><b>2.7</b> Quiz answers</a></li>
<li class="chapter" data-level="2.8" data-path="names-values.html"><a href="names-values.html#summary"><i class="fa fa-check"></i><b>2.8</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="vectors.html"><a href="vectors.html"><i class="fa fa-check"></i><b>3</b> Vectors</a><ul>
<li class="chapter" data-level="3.1" data-path="vectors.html"><a href="vectors.html#introduction-2"><i class="fa fa-check"></i><b>3.1</b> Introduction</a><ul>
<li class="chapter" data-level="" data-path="vectors.html"><a href="vectors.html#quiz-1"><i class="fa fa-check"></i>Quiz</a></li>
<li class="chapter" data-level="" data-path="vectors.html"><a href="vectors.html#outline-1"><i class="fa fa-check"></i>Outline</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="vectors.html"><a href="vectors.html#atomic-vectors"><i class="fa fa-check"></i><b>3.2</b> Atomic vectors</a><ul>
<li class="chapter" data-level="3.2.1" data-path="vectors.html"><a href="vectors.html#scalars"><i class="fa fa-check"></i><b>3.2.1</b> Scalars</a></li>
<li class="chapter" data-level="3.2.2" data-path="vectors.html"><a href="vectors.html#making-longer-vectors-with-c"><i class="fa fa-check"></i><b>3.2.2</b> Making longer vectors with <code>c()</code></a></li>
<li class="chapter" data-level="3.2.3" data-path="vectors.html"><a href="vectors.html#missing-values"><i class="fa fa-check"></i><b>3.2.3</b> Missing values</a></li>
<li class="chapter" data-level="3.2.4" data-path="vectors.html"><a href="vectors.html#testing-and-coercion"><i class="fa fa-check"></i><b>3.2.4</b> Testing and coercion</a></li>
<li class="chapter" data-level="3.2.5" data-path="vectors.html"><a href="vectors.html#exercises-4"><i class="fa fa-check"></i><b>3.2.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="vectors.html"><a href="vectors.html#attributes"><i class="fa fa-check"></i><b>3.3</b> Attributes</a><ul>
<li class="chapter" data-level="3.3.1" data-path="vectors.html"><a href="vectors.html#getting-and-setting"><i class="fa fa-check"></i><b>3.3.1</b> Getting and setting</a></li>
<li class="chapter" data-level="3.3.2" data-path="vectors.html"><a href="vectors.html#names"><i class="fa fa-check"></i><b>3.3.2</b> Names</a></li>
<li class="chapter" data-level="3.3.3" data-path="vectors.html"><a href="vectors.html#dimensions"><i class="fa fa-check"></i><b>3.3.3</b> Dimensions</a></li>
<li class="chapter" data-level="3.3.4" data-path="vectors.html"><a href="vectors.html#exercises-5"><i class="fa fa-check"></i><b>3.3.4</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="vectors.html"><a href="vectors.html#s3-atomic-vectors"><i class="fa fa-check"></i><b>3.4</b> S3 atomic vectors</a><ul>
<li class="chapter" data-level="3.4.1" data-path="vectors.html"><a href="vectors.html#factors"><i class="fa fa-check"></i><b>3.4.1</b> Factors</a></li>
<li class="chapter" data-level="3.4.2" data-path="vectors.html"><a href="vectors.html#dates"><i class="fa fa-check"></i><b>3.4.2</b> Dates</a></li>
<li class="chapter" data-level="3.4.3" data-path="vectors.html"><a href="vectors.html#dates-times"><i class="fa fa-check"></i><b>3.4.3</b> Dates-times</a></li>
<li class="chapter" data-level="3.4.4" data-path="vectors.html"><a href="vectors.html#durations"><i class="fa fa-check"></i><b>3.4.4</b> Durations</a></li>
<li class="chapter" data-level="3.4.5" data-path="vectors.html"><a href="vectors.html#exercises-6"><i class="fa fa-check"></i><b>3.4.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="vectors.html"><a href="vectors.html#lists-1"><i class="fa fa-check"></i><b>3.5</b> Lists</a><ul>
<li class="chapter" data-level="3.5.1" data-path="vectors.html"><a href="vectors.html#creating"><i class="fa fa-check"></i><b>3.5.1</b> Creating</a></li>
<li class="chapter" data-level="3.5.2" data-path="vectors.html"><a href="vectors.html#testing-and-coercion-1"><i class="fa fa-check"></i><b>3.5.2</b> Testing and coercion</a></li>
<li class="chapter" data-level="3.5.3" data-path="vectors.html"><a href="vectors.html#matrices-and-arrays"><i class="fa fa-check"></i><b>3.5.3</b> Matrices and arrays</a></li>
<li class="chapter" data-level="3.5.4" data-path="vectors.html"><a href="vectors.html#exercises-7"><i class="fa fa-check"></i><b>3.5.4</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="vectors.html"><a href="vectors.html#data-frames-and-tibbles"><i class="fa fa-check"></i><b>3.6</b> Data frames and tibbles</a><ul>
<li class="chapter" data-level="3.6.1" data-path="vectors.html"><a href="vectors.html#creating-1"><i class="fa fa-check"></i><b>3.6.1</b> Creating</a></li>
<li class="chapter" data-level="3.6.2" data-path="vectors.html"><a href="vectors.html#row-names"><i class="fa fa-check"></i><b>3.6.2</b> Row names</a></li>
<li class="chapter" data-level="3.6.3" data-path="vectors.html"><a href="vectors.html#printing"><i class="fa fa-check"></i><b>3.6.3</b> Printing</a></li>
<li class="chapter" data-level="3.6.4" data-path="vectors.html"><a href="vectors.html#subsetting"><i class="fa fa-check"></i><b>3.6.4</b> Subsetting</a></li>
<li class="chapter" data-level="3.6.5" data-path="vectors.html"><a href="vectors.html#testing-and-coercing"><i class="fa fa-check"></i><b>3.6.5</b> Testing and coercing</a></li>
<li class="chapter" data-level="3.6.6" data-path="vectors.html"><a href="vectors.html#list-columns"><i class="fa fa-check"></i><b>3.6.6</b> List columns</a></li>
<li class="chapter" data-level="3.6.7" data-path="vectors.html"><a href="vectors.html#matrix-and-data-frame-columns"><i class="fa fa-check"></i><b>3.6.7</b> Matrix and data frame columns</a></li>
<li class="chapter" data-level="3.6.8" data-path="vectors.html"><a href="vectors.html#exercises-8"><i class="fa fa-check"></i><b>3.6.8</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3.7" data-path="vectors.html"><a href="vectors.html#null"><i class="fa fa-check"></i><b>3.7</b> NULL</a></li>
<li class="chapter" data-level="3.8" data-path="vectors.html"><a href="vectors.html#quiz-answers-1"><i class="fa fa-check"></i><b>3.8</b> Quiz answers</a></li>
<li class="chapter" data-level="3.9" data-path="vectors.html"><a href="vectors.html#summary-1"><i class="fa fa-check"></i><b>3.9</b> Summary</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Advanced R in Korean</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="vectors" class="section level1">
<h1><span class="header-section-number">Chapter 3</span> Vectors</h1>
<div id="introduction-2" class="section level2">
<h2><span class="header-section-number">3.1</span> Introduction</h2>
<p>이 Chapter에서는 R의 기본 데이터 타입들 중 가장 중요한, 벡터에 대해 이야기하려 합니다. 아마 당신은 여러 종류의 벡터들을 이미 사용해왔겠지만, 아마 그것들이 서로 어떤 연관성이 있는지에 대해서는 깊게 생각해보지 않았을 겁니다. 이번 Chapter에서 모든 벡터 타입들을 너무 자세히 다루지는 않겠지만, 이 타입들이 전체적으로 어떻게 들어맞는지 보여드리겠습니다. 만약 더 자세히 알고 싶다면, R 문서를 찾아보시면 되겠습니다.</p>
<p>벡터는 두가지 맛이 있는데, 원자(atomic) 벡터와 리스트입니다. 이들은 가지고 있는 원소 타입에 차이가 있는데, 원자 벡터는 모든 원소가 반드시 같은 타입이어야만 하고, 리스트는 다른 타입의 원소들을 가질 수 있습니다. 벡터는 아니지만, <code>NULL</code>도 벡터와 밀접히 관련되어 있고, 종종 길이가 0인 일반 벡터의 역할을 하기도 합니다. 이 다이어그램이 기본적인 관계들을 표현해주고 있습니다. Chapter가 진행됨에 따라 다이어그램을 확장해보겠습니다.</p>
<p><img src="diagrams/vectors/summary-tree.png" style="display: block; margin: auto;" /></p>
<p>모든 벡터는 또한 _특성(attribute)_를 가질 수 있는데, 이름이 붙은 임의의 메타데이터라고 볼 수 있습니다. 특성 중 두 개가 특별히 중요합니다. <em>차원(dimension)</em> 특성은 벡터를 행렬(matrices)이나 배열(array)로 바꿔주고, <em>클래스(class)</em> 특성은 S3 객체 시스템을 강화합니다. S3를 어떻게 사용하는 지는 Chapter 13에서 배우겠지만, 여기에서도 가장 중요한 S3 벡터인 팩터(factors), 날짜 시간(date and times), 데이터 프레임(data frames), 그리고 티블(tibbles)에 대해 배울 것입니다. 행렬이나 데이터 프레임 같은 2D 구조들은 딱히 벡터 같다고 생각되지 않을 수 있는데, 왜 R이 이들을 벡터로 간주하는지도 배우게 됩니다.</p>
<div id="quiz-1" class="section level3 unnumbered">
<h3>Quiz</h3>
<p>이 짧은 퀴즈를 풀어보고 이 Chapter를 읽을 필요가 있는지 확인해 봅시다. 만약 답이 금방 떠오른다면, 이 Chapter를 편안히 넘겨도 됩니다. Section 3.8에서 답을 확인해보세요.</p>
<ol style="list-style-type: decimal">
<li><p>네 가지 일반적인 유형의 atomic 벡터는 무엇입니까? 두 가지 희귀한 유형은 무엇인가요?</p></li>
<li><p>특성(attributes)가 무엇입니까? 어떻게 구할 수 있고 설정할 수 있습니까?</p></li>
<li><p>리스트는 atomic 벡터와 어떻게 다른가요? 또 행렬은 데이터 프레임과 어떻게 다릅니까?</p></li>
<li><p>행렬인 리스트를 가질 수 있습니까? 데이터 프레임이 행렬을 열로 가질 수 있습니까?</p></li>
<li><p>티블(tibbles)는 데이터 프레임과 어떻게 다르게 동작합니까?</p></li>
</ol>
</div>
<div id="outline-1" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section 3.2에서는 논리형(logical), 정수형(integer), 실수형(double), 문자형(character)이라는 atomic 벡터들을 소개하겠습니다. 이는 R의 가장 간단한 데이터 구조들입니다.</p></li>
<li><p>Section 3.3에서는 R의 유연한 메타데이터 설명서인 특성(attributes)를 논합니다. 가장 중요한 특성들은 이름(names), 차원(dimensions), 그리고 클래스(class)입니다.</p></li>
<li><p>Section 3.4는 atomic 벡터와 특별한 특성이 결합되어 만들어진 중요한 벡터 타입들에 대해 다룹니다. 이는 팩터(factors), 날짜(dates), 날짜-시간(date-times), 그리고 지속시간(durations)를 포함합니다.</p></li>
<li><p>Section 3.5에선 리스트를 깊게 살펴봅니다. 리스트는 atomic 벡터와 매우 비슷하지만, 한가지 중요한 차이가 있습니다. 바로 리스트는 다른 리스트를 포함해 모든 데이터 타입을 원소로 가질 수 있다는 것입니다. 이 특징은 계층적인 데이터를 표현하기 적합하게 만들어줍니다.</p></li>
<li><p>Section 3.6은 데이터 프레임과 티블에 대해 가르쳐줍니다. 이들은 직사각형 모양 데이터를 나타낼 때 사용됩니다. 또한 리스트와 행렬의 특징이 결합되어 있어, 통계적 데이터를 다루는 데에도 매우 적합한 구조입니다.</p></li>
</ul>
</div>
</div>
<div id="atomic-vectors" class="section level2">
<h2><span class="header-section-number">3.2</span> Atomic vectors</h2>
<p>논리형(logical), 정수형(integer), 실수형(double), 문자형(character)은 atomic 벡터의 네 가지 기본 유형입니다. 정수형과 실수형 벡터들은 합쳐서 숫자형(numeric) 벡터로도 알려져 있습니다. 복소수형(complex)과 Raw 타입은 두 가지 희귀 유형입니다. 이들을 더 깊게 다루지는 않으려고 하는데, 복소수형은 통계학에서는 거의 쓸 일이 없고, raw 벡터는 binary 데이터를 다룰 때만 필요한 특수한 유형이기 때문입니다.</p>
<p><img src="diagrams/vectors/summary-tree-atomic.png" style="display: block; margin: auto;" /></p>
<div id="scalars" class="section level3">
<h3><span class="header-section-number">3.2.1</span> Scalars</h3>
<p>각 네 가지 기본 타입들은 개별 값을 생성하기 위해, 일명 _scalar_라고 하는 특별한 문법을 갖고 있습니다.</p>
<ul>
<li><p>논리형은 풀 네임(<code>TRUE</code> 또는 <code>FALSE</code>), 또는 축약 버전(<code>T</code> 또는 <code>F</code>)으로 쓸 수 있습니다.</p></li>
<li><p>실수형은 10진법(<code>0.1234</code>), 지수표기법(<code>1.23e4</code>), 또는 16진법(<code>0xcafe</code>) 형태로 표기될 수 있습니다. 실수형에만 있는 세 가지 특별한 값이 있습니다. <code>Inf</code>, <code>-Inf</code>, 그리고 <code>NaN</code>(not a number)인데, 이들은 부동 소수점 표준에 의해 정의된 특수한 값입니다.</p></li>
<li><p>정수형은 실수형과 비슷하게 쓰여지지만 반드시 <code>L</code>를 뒤에 붙여주어야 합니다.(<code>1234L</code>, <code>1e4L</code>, 또는 <code>0xcafeL</code>) 그리고 분수를 포함할 수 없습니다.</p></li>
<li><p>문자형은 <code>"</code>(<code>"hi"</code>) 또는 <code>'</code>(<code>'bye'</code>)로 감싸집니다. 특수한 문자들은 <code>\</code>를 이용해 이스케이프 할 수 있는데, 자세한 내용은 <code>?Quotes</code>에서 확인하세요.</p></li>
</ul>
</div>
<div id="making-longer-vectors-with-c" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Making longer vectors with <code>c()</code></h3>
<p>짧은 벡터들을 가지고 더 긴 벡터들을 만들고 싶다면, <code>c()</code>를 사용하세요.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb54-1" title="1">lgl_var &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb54-2" title="2">int_var &lt;-<span class="st"> </span><span class="kw">c</span>(1L, 6L, 10L)</a>
<a class="sourceLine" id="cb54-3" title="3">dbl_var &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="fl">2.5</span>, <span class="fl">4.5</span>)</a>
<a class="sourceLine" id="cb54-4" title="4">chr_var &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;these are&quot;</span>, <span class="st">&quot;some strings&quot;</span>)</a></code></pre></div>
<p>인풋값이 atomic 벡터라면, <code>c()</code>는 항상 다른 atomic 벡터를 만들어냅니다.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb55-1" title="1"><span class="kw">c</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb55-2" title="2"><span class="co">#&gt; [1] 1 2 3 4</span></a></code></pre></div>
<p>다이어그램에서 벡터들은 연결된 직사각형으로 표현했습니다. 위의 코드는 아래와 같이 표현할 수 있습니다.</p>
<p><img src="diagrams/vectors/atomic.png" style="display: block; margin: auto;" /></p>
<p><code>typeof()</code>를 이용해서 벡터의 타입을, <code>length()</code>로 길이를 확인할 수 있습니다.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb56-1" title="1"><span class="kw">typeof</span>(lgl_var)</a>
<a class="sourceLine" id="cb56-2" title="2"><span class="co">#&gt; [1] &quot;logical&quot;</span></a>
<a class="sourceLine" id="cb56-3" title="3"><span class="kw">typeof</span>(int_var)</a>
<a class="sourceLine" id="cb56-4" title="4"><span class="co">#&gt; [1] &quot;integer&quot;</span></a>
<a class="sourceLine" id="cb56-5" title="5"><span class="kw">typeof</span>(dbl_var)</a>
<a class="sourceLine" id="cb56-6" title="6"><span class="co">#&gt; [1] &quot;double&quot;</span></a>
<a class="sourceLine" id="cb56-7" title="7"><span class="kw">typeof</span>(chr_var)</a>
<a class="sourceLine" id="cb56-8" title="8"><span class="co">#&gt; [1] &quot;character&quot;</span></a></code></pre></div>
</div>
<div id="missing-values" class="section level3">
<h3><span class="header-section-number">3.2.3</span> Missing values</h3>
<p>R은, 특수한 값인 <code>NA</code>(not applicable의 약자)를 이용해서 결측값이나 미지의 값을 나타냅니다. 결측값은 전염되는 성질이 있습니다. 결측값을 포함하는 대부분의 연산은 또 다른 결측값을 내놓습니다.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb57-1" title="1"><span class="ot">NA</span> <span class="op">&gt;</span><span class="st"> </span><span class="dv">5</span></a>
<a class="sourceLine" id="cb57-2" title="2"><span class="co">#&gt; [1] NA</span></a>
<a class="sourceLine" id="cb57-3" title="3"><span class="dv">10</span> <span class="op">*</span><span class="st"> </span><span class="ot">NA</span></a>
<a class="sourceLine" id="cb57-4" title="4"><span class="co">#&gt; [1] NA</span></a>
<a class="sourceLine" id="cb57-5" title="5"><span class="op">!</span><span class="ot">NA</span></a>
<a class="sourceLine" id="cb57-6" title="6"><span class="co">#&gt; [1] NA</span></a></code></pre></div>
<p>이 규칙에는 몇 가지 예외가 있는데, 모든 가능한 입력값에 대해 동일한 결과를 도출하는 경우에만 발생합니다.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb58-1" title="1"><span class="ot">NA</span> <span class="op">^</span><span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb58-2" title="2"><span class="co">#&gt; [1] 1</span></a>
<a class="sourceLine" id="cb58-3" title="3"><span class="ot">NA</span> <span class="op">|</span><span class="st"> </span><span class="ot">TRUE</span></a>
<a class="sourceLine" id="cb58-4" title="4"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb58-5" title="5"><span class="ot">NA</span> <span class="op">&amp;</span><span class="st"> </span><span class="ot">FALSE</span></a>
<a class="sourceLine" id="cb58-6" title="6"><span class="co">#&gt; [1] FALSE</span></a></code></pre></div>
<p>결측치가 옮겨가는 현상 때문에 벡터 안의 결측값을 찾아내려 할 때 흔히 실수가 발생합니다.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb59-1" title="1">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">NA</span>, <span class="dv">5</span>, <span class="ot">NA</span>, <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb59-2" title="2">x <span class="op">==</span><span class="st"> </span><span class="ot">NA</span></a>
<a class="sourceLine" id="cb59-3" title="3"><span class="co">#&gt; [1] NA NA NA NA</span></a></code></pre></div>
<p>한 결측값이 다른 것과 같은 값을 가지리란 보장이 없기 때문에, 이러한 결과는 합당하다고 볼 수 있습니다. 대신에 <code>is.na()</code>를 사용하면 결측의 존재를 확인할 수 있습니다.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb60-1" title="1"><span class="kw">is.na</span>(x)</a>
<a class="sourceLine" id="cb60-2" title="2"><span class="co">#&gt; [1]  TRUE FALSE  TRUE FALSE</span></a></code></pre></div>
</div>
<div id="testing-and-coercion" class="section level3">
<h3><span class="header-section-number">3.2.4</span> Testing and coercion</h3>
<p>일반적으로 <code>is.*()</code> 함수로 벡터가 주어진 타입의 것인지 _테스트_할 수 있습니다. 하지만 이 함수들은 주의해서 사용해야합니다. <code>is.logical()</code>, <code>is.integer()</code>, <code>is.double()</code>, 그리고 <code>is.character()</code>은 우리가 예상하는대로, 벡터가 문자형인지 실수형인지 정수형인지 논리형인지 확인해줍니다. <code>is.vector()</code>, <code>is.atomic()</code>, <code>is.numeric()</code>은 사용하지 마세요. 이들은 벡터인지 atomic 벡터인지 숫자형인지 확인하지 않습니다. 문서를 주의깊게 읽어 이들이 실제로 무엇을 하는지 알아보세요.</p>
<p>atomic vectors에게, 타입은 벡터 전체의 성질입니다. 모든 원소가 같은 타입을 가져야하니까요. 만약 다른 타입들을 결합하려한다면, 지정된 순서에 따라 _강제(coerced)_됩니다.</p>
<p>순서 : 문자형 → 실수형 → 정수형 → 논리형</p>
<p>예를 들어, 문자형과 정수형의 결합은 문자형이 됩니다.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb61-1" title="1"><span class="kw">str</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb61-2" title="2"><span class="co">#&gt;  chr [1:2] &quot;a&quot; &quot;1&quot;</span></a></code></pre></div>
<p>Coercion은 대개 자동으로 일어납니다. 대부분의 수학 관련 함수들(<code>+</code>, <code>log</code>, <code>abs</code> 등)은 숫자로 강제합니다. 이런 종류의 coercion은 논리형 벡터들에 대해 특히 유용한데, <code>TRUE</code>는 1이 되고 <code>FALSE</code>는 0이 되기 때문입니다.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb62-1" title="1">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">FALSE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb62-2" title="2"><span class="kw">as.numeric</span>(x)</a>
<a class="sourceLine" id="cb62-3" title="3"><span class="co">#&gt; [1] 0 0 1</span></a>
<a class="sourceLine" id="cb62-4" title="4"></a>
<a class="sourceLine" id="cb62-5" title="5"><span class="co"># Total number of TRUEs</span></a>
<a class="sourceLine" id="cb62-6" title="6"><span class="kw">sum</span>(x)</a>
<a class="sourceLine" id="cb62-7" title="7"><span class="co">#&gt; [1] 1</span></a>
<a class="sourceLine" id="cb62-8" title="8"></a>
<a class="sourceLine" id="cb62-9" title="9"><span class="co"># Proportion that are TRUE</span></a>
<a class="sourceLine" id="cb62-10" title="10"><span class="kw">mean</span>(x)</a>
<a class="sourceLine" id="cb62-11" title="11"><span class="co">#&gt; [1] 0.333</span></a></code></pre></div>
<p><code>as.logical()</code>, <code>as.integer()</code>, <code>as.double()</code>, <code>as.character()</code>과 같은 <code>as.*()</code> 함수를 사용해서 고의적으로 강제할 수 있습니다. 문자를 강제하는데 실패하는 경우 경고와 결측값이 생깁니다.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb63-1" title="1"><span class="kw">as.integer</span>(<span class="kw">c</span>(<span class="st">&quot;1&quot;</span>, <span class="st">&quot;1.5&quot;</span>, <span class="st">&quot;a&quot;</span>))</a>
<a class="sourceLine" id="cb63-2" title="2"><span class="co">#&gt; Warning: 강제형변환에 의해 생성된 NA 입니다</span></a>
<a class="sourceLine" id="cb63-3" title="3"><span class="co">#&gt; [1]  1  1 NA</span></a></code></pre></div>
</div>
<div id="exercises-4" class="section level3">
<h3><span class="header-section-number">3.2.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>raw와 complex scalar를 어떻게 만들 수 있을까요?</p></li>
<li><p>아래의 결과물을 예상하며 벡터 coercion에 대한 지식을 확인해보세요.</p></li>
</ol>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb64-1" title="1"><span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb64-2" title="2"><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb64-3" title="3"><span class="kw">c</span>(<span class="ot">TRUE</span>, 1L)</a></code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li><p>왜 <code>1 =="1"</code>이 참일까요? 왜 <code>-1 &lt; FALSE</code>는 참일까요? 왜 <code>"one" &lt; 2</code>는 거짓일까요?</p></li>
<li><p>왜 디폴트 <code>NA</code>는 논리형 벡터일까요? 논리형 벡터의 특별한 점은 무엇인가요?(힌트: <code>c(FALSE, NA_character_)</code>를 생각해보세요)</p></li>
<li><p>정확히 <code>is.atomic()</code>, <code>is.numeric()</code>, <code>is.vector()</code>는 무엇을 테스트하나요?</p></li>
</ol>
</div>
</div>
<div id="attributes" class="section level2">
<h2><span class="header-section-number">3.3</span> Attributes</h2>
<p>아마 atomic 벡터 시리즈가 행렬, 배열, 팩터, 날짜-시간 데이터와 같이 많은 중요한 데이터 구조들을 포함하지 않는다는 사실을 눈치채셨을 것 같습니다. 이 타입들은 atomic 벡터에 속성(attributes)를 추가하여 구축됩니다. 이 Section에서는 속성의 기초와, 어떻게 차원(dim) 속성이 행렬과 배열을 만들어 내는지 배웁니다. 다음 Section에서 어떻게 클래스 속성이 팩터, 날짜, 날짜-시간과 같은 S3 벡터들을 만드는지 배우겠습니다.</p>
<div id="getting-and-setting" class="section level3">
<h3><span class="header-section-number">3.3.1</span> Getting and setting</h3>
<p>속성이란 객체에 메타데이터를 더해주는 이름과 값의 쌍이라고 볼 수 있습니다. 개개의 속성들은 <code>attr()</code>를 사용하여 검색하거나 수정할 수 있고, <code>attributes()</code>를 사용하여 전체를 검색하고 <code>structure()</code>를 사용해서 일괄 설정할 수 있습니다.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb65-1" title="1">a &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">3</span></a>
<a class="sourceLine" id="cb65-2" title="2"><span class="kw">attr</span>(a, <span class="st">&quot;x&quot;</span>) &lt;-<span class="st"> &quot;abcdef&quot;</span></a>
<a class="sourceLine" id="cb65-3" title="3"><span class="kw">attr</span>(a, <span class="st">&quot;x&quot;</span>)</a>
<a class="sourceLine" id="cb65-4" title="4"><span class="co">#&gt; [1] &quot;abcdef&quot;</span></a>
<a class="sourceLine" id="cb65-5" title="5"></a>
<a class="sourceLine" id="cb65-6" title="6"><span class="kw">attr</span>(a, <span class="st">&quot;y&quot;</span>) &lt;-<span class="st"> </span><span class="dv">4</span><span class="op">:</span><span class="dv">6</span></a>
<a class="sourceLine" id="cb65-7" title="7"><span class="kw">str</span>(<span class="kw">attributes</span>(a))</a>
<a class="sourceLine" id="cb65-8" title="8"><span class="co">#&gt; List of 2</span></a>
<a class="sourceLine" id="cb65-9" title="9"><span class="co">#&gt;  $ x: chr &quot;abcdef&quot;</span></a>
<a class="sourceLine" id="cb65-10" title="10"><span class="co">#&gt;  $ y: int [1:3] 4 5 6</span></a>
<a class="sourceLine" id="cb65-11" title="11"></a>
<a class="sourceLine" id="cb65-12" title="12"><span class="co"># Or equivalently</span></a>
<a class="sourceLine" id="cb65-13" title="13">a &lt;-<span class="st"> </span><span class="kw">structure</span>(</a>
<a class="sourceLine" id="cb65-14" title="14">  <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, </a>
<a class="sourceLine" id="cb65-15" title="15">  <span class="dt">x =</span> <span class="st">&quot;abcdef&quot;</span>,</a>
<a class="sourceLine" id="cb65-16" title="16">  <span class="dt">y =</span> <span class="dv">4</span><span class="op">:</span><span class="dv">6</span></a>
<a class="sourceLine" id="cb65-17" title="17">)</a>
<a class="sourceLine" id="cb65-18" title="18"><span class="kw">str</span>(<span class="kw">attributes</span>(a))</a>
<a class="sourceLine" id="cb65-19" title="19"><span class="co">#&gt; List of 2</span></a>
<a class="sourceLine" id="cb65-20" title="20"><span class="co">#&gt;  $ x: chr &quot;abcdef&quot;</span></a>
<a class="sourceLine" id="cb65-21" title="21"><span class="co">#&gt;  $ y: int [1:3] 4 5 6</span></a></code></pre></div>
<p><img src="diagrams/vectors/attr.png" style="display: block; margin: auto;" /></p>
<p>속성은 일반적으로는 일시적이라고 생각해야 합니다. 예를 들어, 대부분의 속성들은 대부분의 연산에 의해 사라집니다.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb66-1" title="1"><span class="kw">attributes</span>(a[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb66-2" title="2"><span class="co">#&gt; NULL</span></a>
<a class="sourceLine" id="cb66-3" title="3"><span class="kw">attributes</span>(<span class="kw">sum</span>(a))</a>
<a class="sourceLine" id="cb66-4" title="4"><span class="co">#&gt; NULL</span></a></code></pre></div>
<p>일상적으로 보존되는 속성은 두가지 뿐입니다.</p>
<ul>
<li><strong>이름(names)</strong>: 각 요소에 이름을 부여하는 문자형 벡터입니다.</li>
<li><strong>차원(dim)</strong>: dimensions의 약자로, 벡터를 행렬이나 배열로 만들어주는 정수형 벡터입니다.</li>
</ul>
<p>다른 속성들을 보존하기 위해선, Chapter 13의 주제인, S3 클래스를 만들어 사용해야 합니다.</p>
</div>
<div id="names" class="section level3">
<h3><span class="header-section-number">3.3.2</span> Names</h3>
<p>세 가지 방식으로 벡터에 이름을 부여할 수 있습니다.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb67-1" title="1"><span class="co"># When creating it: </span></a>
<a class="sourceLine" id="cb67-2" title="2">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>, <span class="dt">c =</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb67-3" title="3"></a>
<a class="sourceLine" id="cb67-4" title="4"><span class="co"># By assigning a character vector to names()</span></a>
<a class="sourceLine" id="cb67-5" title="5">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">3</span></a>
<a class="sourceLine" id="cb67-6" title="6"><span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)</a>
<a class="sourceLine" id="cb67-7" title="7"></a>
<a class="sourceLine" id="cb67-8" title="8"><span class="co"># Inline, with setNames():</span></a>
<a class="sourceLine" id="cb67-9" title="9">x &lt;-<span class="st"> </span><span class="kw">setNames</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>))</a></code></pre></div>
<p><code>attr(x, "names")</code>는 <code>names(x)</code>에 비해 타이핑도 많이 해야하고 가독성이 떨어지므로 사용을 피해주세요. <code>unname(x)</code> 또는 <code>names(x) &lt;- NULL</code>을 사용해 벡터의 이름을 제거할 수도 있습니다.</p>
<p>기술적으로 정확히 하기 위해, 이름이 있는 벡터 <code>x</code>를 그릴 때는 다음과 같이 그려야 합니다.</p>
<p><img src="diagrams/vectors/attr-names-1.png" style="display: block; margin: auto;" /></p>
<p>하지만 이름은 너무 특별하고 중요하기 때문에, 데이터의 속성 구조에 각별히 주의를 기울이지 않는 한은, 벡터에 직접 라벨을 주도록 하겠습니다.</p>
<p><img src="diagrams/vectors/attr-names-2.png" style="display: block; margin: auto;" /></p>
<p>문자를 이용한 서브 세팅의 편리를 위해, 이름은 고유해야하고 결측이 아니어야만 합니다. 하지만 이건 R이 강제하는 바는 아닙니다. 이름이 어떻게 설정되냐에 따라, 누락된 이름은 <code>""</code> 또는 <code>NA_character_</code>이 될 수도 있습니다. 만약 모든 이름이 누락되어 있다면, <code>names()</code>는 <code>NULL</code>을 반환합니다.</p>
</div>
<div id="dimensions" class="section level3">
<h3><span class="header-section-number">3.3.3</span> Dimensions</h3>
<p><code>dim</code> 속성을 벡터에 추가하는 것은 벡터가 2차원 _행렬_이나 다차원 _배열_처럼 작동할 수 있게 해줍니다. 행렬과 배열은 주로 수학이나 통계학적 도구이지, 프로그래밍 도구는 아닙니다. 따라서 이들은 자주 사용되지는 않으므로 이 책에서는 간략히 다루겠습니다. 이것들의 가장 중요한 특징은 Section 4.2.3에서 다룰 다차원 세브세팅입니다.</p>
<p>행렬과 배열을 만들기 위해서는 <code>matrix()</code>와 <code>array()</code>를 사용하거나, <code>dim()</code> 형태의 할당을 사용할 수 있습니다.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb68-1" title="1"><span class="co"># Two scalar arguments specify row and column sizes</span></a>
<a class="sourceLine" id="cb68-2" title="2">a &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>, <span class="dt">nrow =</span> <span class="dv">2</span>, <span class="dt">ncol =</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb68-3" title="3">a</a>
<a class="sourceLine" id="cb68-4" title="4"><span class="co">#&gt;      [,1] [,2] [,3]</span></a>
<a class="sourceLine" id="cb68-5" title="5"><span class="co">#&gt; [1,]    1    3    5</span></a>
<a class="sourceLine" id="cb68-6" title="6"><span class="co">#&gt; [2,]    2    4    6</span></a>
<a class="sourceLine" id="cb68-7" title="7"></a>
<a class="sourceLine" id="cb68-8" title="8"><span class="co"># One vector argument to describe all dimensions</span></a>
<a class="sourceLine" id="cb68-9" title="9">b &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">12</span>, <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb68-10" title="10">b</a>
<a class="sourceLine" id="cb68-11" title="11"><span class="co">#&gt; , , 1</span></a>
<a class="sourceLine" id="cb68-12" title="12"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb68-13" title="13"><span class="co">#&gt;      [,1] [,2] [,3]</span></a>
<a class="sourceLine" id="cb68-14" title="14"><span class="co">#&gt; [1,]    1    3    5</span></a>
<a class="sourceLine" id="cb68-15" title="15"><span class="co">#&gt; [2,]    2    4    6</span></a>
<a class="sourceLine" id="cb68-16" title="16"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb68-17" title="17"><span class="co">#&gt; , , 2</span></a>
<a class="sourceLine" id="cb68-18" title="18"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb68-19" title="19"><span class="co">#&gt;      [,1] [,2] [,3]</span></a>
<a class="sourceLine" id="cb68-20" title="20"><span class="co">#&gt; [1,]    7    9   11</span></a>
<a class="sourceLine" id="cb68-21" title="21"><span class="co">#&gt; [2,]    8   10   12</span></a>
<a class="sourceLine" id="cb68-22" title="22"></a>
<a class="sourceLine" id="cb68-23" title="23"><span class="co"># You can also modify an object in place by setting dim()</span></a>
<a class="sourceLine" id="cb68-24" title="24">c &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">6</span></a>
<a class="sourceLine" id="cb68-25" title="25"><span class="kw">dim</span>(c) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb68-26" title="26">c</a>
<a class="sourceLine" id="cb68-27" title="27"><span class="co">#&gt;      [,1] [,2]</span></a>
<a class="sourceLine" id="cb68-28" title="28"><span class="co">#&gt; [1,]    1    4</span></a>
<a class="sourceLine" id="cb68-29" title="29"><span class="co">#&gt; [2,]    2    5</span></a>
<a class="sourceLine" id="cb68-30" title="30"><span class="co">#&gt; [3,]    3    6</span></a></code></pre></div>
<p>벡터에 작동하는 많은 함수들은 행렬과 배열에도 일반화가 가능합니다.</p>
<table>
<thead>
<tr class="header">
<th>Vector</th>
<th>Matrix</th>
<th>Array</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>names()</code></td>
<td><code>rownames()</code>, <code>colnames()</code></td>
<td><code>dimnames()</code></td>
</tr>
<tr class="even">
<td><code>length()</code></td>
<td><code>nrow()</code>, <code>ncol()</code></td>
<td><code>dim()</code></td>
</tr>
<tr class="odd">
<td><code>c()</code></td>
<td><code>rbind()</code>, <code>cbind()</code></td>
<td><code>abind::abind()</code></td>
</tr>
<tr class="even">
<td>—</td>
<td><code>t()</code></td>
<td><code>aperm()</code></td>
</tr>
<tr class="odd">
<td><code>is.null(dim(x))</code></td>
<td><code>is.matrix()</code></td>
<td><code>is.array()</code></td>
</tr>
</tbody>
</table>
<p><code>dim</code> 속성이 없는 벡터는 1차원으로 생각되지만, 실제로는 <code>NULL</code> 차원입니다. 하나의 행이나 열을 가지는 행렬이나, 1차원인 배열도 만들 수 있습니다. 이들은 비슷하게 출력되지만, 다르게 동작합니다. 이 차이점들은 그리 중요하진 않지만, 알아두면 함수가 이상한 결과물을 뱉는 경우에 유용할 수 있습니다.(<code>tapply()</code>가 빈번히 이럽디다) 뭐 여느때와 마찬가지로, <code>str()</code>을 이용해서 차이점을 확인할 수 있습니다.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb69-1" title="1"><span class="kw">str</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)                   <span class="co"># 1d vector</span></a>
<a class="sourceLine" id="cb69-2" title="2"><span class="co">#&gt;  int [1:3] 1 2 3</span></a>
<a class="sourceLine" id="cb69-3" title="3"><span class="kw">str</span>(<span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">ncol =</span> <span class="dv">1</span>)) <span class="co"># column vector</span></a>
<a class="sourceLine" id="cb69-4" title="4"><span class="co">#&gt;  int [1:3, 1] 1 2 3</span></a>
<a class="sourceLine" id="cb69-5" title="5"><span class="kw">str</span>(<span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">nrow =</span> <span class="dv">1</span>)) <span class="co"># row vector</span></a>
<a class="sourceLine" id="cb69-6" title="6"><span class="co">#&gt;  int [1, 1:3] 1 2 3</span></a>
<a class="sourceLine" id="cb69-7" title="7"><span class="kw">str</span>(<span class="kw">array</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dv">3</span>))         <span class="co"># &quot;array&quot; vector</span></a>
<a class="sourceLine" id="cb69-8" title="8"><span class="co">#&gt;  int [1:3(1d)] 1 2 3</span></a></code></pre></div>
</div>
<div id="exercises-5" class="section level3">
<h3><span class="header-section-number">3.3.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p><code>setNames()</code>와 <code>unname()</code>은 어떻게 구현되어 있습니까? 소스 코드를 읽어보세요.</p></li>
<li><p><code>dim()</code>이 1차원 벡터에게 적용되었을 때 무엇이 반환됩니까? <code>NROW()</code>나 <code>NCOL()</code>은 언제 사용하나요?</p></li>
<li><p>다음 세 객체를 어떻게 설명하시겠습니까? <code>1:5</code>와 다른 점이 무엇인가요?</p></li>
</ol>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb70-1" title="1">x1 &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">5</span>))</a>
<a class="sourceLine" id="cb70-2" title="2">x2 &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb70-3" title="3">x3 &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">1</span>))</a></code></pre></div>
<ol start="4" style="list-style-type: decimal">
<li>초기 원고에서는 <code>structure()</code>를 표현하기 위해 이 코드를 사용했었습니다.</li>
</ol>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb71-1" title="1"><span class="kw">structure</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">comment =</span> <span class="st">&quot;my attribute&quot;</span>)</a>
<a class="sourceLine" id="cb71-2" title="2"><span class="co">#&gt; [1] 1 2 3 4 5</span></a></code></pre></div>
<p>하지만 이 객체를 프린트하면 comment 속성을 볼 수 없습니다. 왜일까요? 속성이 누락된 것일까요? 아니면 뭔가 특별한 것이 있는 걸까요?(힌트: help를 사용해보세요)</p>
</div>
</div>
<div id="s3-atomic-vectors" class="section level2">
<h2><span class="header-section-number">3.4</span> S3 atomic vectors</h2>
<p>벡터의 가장 중요한 속성 중 하나는 S3 객체 시스템의 근간을 이루는 <code>class</code>입니다. 클래스 속성을 가지게 되면 객체가 <strong>S3 객체</strong>로 바뀝니다. 이는 <strong>제네릭(generic)</strong> 함수를 거쳤을 때, 일반적인 벡터와는 다른 행태를 보인다는 것을 의미합니다. 모든 S3 객체는 기본 타입을 기반으로 형성되고, 종종 다른 속성들에 대한 추가 정보를 저장하기도 합니다. Chapter 13에서 S3 객체 시스템에 대한 디테일과 어떻게 자신만의 S3 클래스를 만들 수 있는지 배울 것입니다.</p>
<p>이 Section에서는, 베이스 R에서 사용되는 네 가지 중요한 S3 벡터들에 대해 논할 것입니다.</p>
<ul>
<li><p><strong>팩터(factor)</strong> 벡터에 기록된 정해진 레벨들의 후보에서 값이 비롯되는 범주형 데이터</p></li>
<li><p><strong>날짜(Date)</strong> 벡터에 기록된 날짜들(요일 등까지도)</p></li>
<li><p><strong>POSIXct</strong> 벡터들에 저장된 날짜-시간들(초 아래 단위까지도)</p></li>
<li><p><strong>difftime</strong> 벡터에 저장된 지속기간들</p></li>
</ul>
<p><img src="diagrams/vectors/summary-tree-s3-1.png" style="display: block; margin: auto;" /></p>
<div id="factors" class="section level3">
<h3><span class="header-section-number">3.4.1</span> Factors</h3>
<p>팩터는 사전에 정의된 값들만을 가질 수 있는 벡터입니다. 이는 범주형 데이터를 저장하는 데에 사용됩니다. 팩터는 정수형 벡터에 두가지 속성이 더해져 만들어집니다. 일반적인 정수형 벡터들과 다르게 동작하게 해주는 “팩터” <code>class</code>와, 허용된 값들을 정의하는 <code>levels</code>가 그것입니다.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb72-1" title="1">x &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;a&quot;</span>))</a>
<a class="sourceLine" id="cb72-2" title="2">x</a>
<a class="sourceLine" id="cb72-3" title="3"><span class="co">#&gt; [1] a b b a</span></a>
<a class="sourceLine" id="cb72-4" title="4"><span class="co">#&gt; Levels: a b</span></a>
<a class="sourceLine" id="cb72-5" title="5"></a>
<a class="sourceLine" id="cb72-6" title="6"><span class="kw">typeof</span>(x)</a>
<a class="sourceLine" id="cb72-7" title="7"><span class="co">#&gt; [1] &quot;integer&quot;</span></a>
<a class="sourceLine" id="cb72-8" title="8"><span class="kw">attributes</span>(x)</a>
<a class="sourceLine" id="cb72-9" title="9"><span class="co">#&gt; $levels</span></a>
<a class="sourceLine" id="cb72-10" title="10"><span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot;</span></a>
<a class="sourceLine" id="cb72-11" title="11"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb72-12" title="12"><span class="co">#&gt; $class</span></a>
<a class="sourceLine" id="cb72-13" title="13"><span class="co">#&gt; [1] &quot;factor&quot;</span></a></code></pre></div>
<p><img src="diagrams/vectors/factor.png" style="display: block; margin: auto;" /></p>
<p>팩터는 가능한 값 세트를 알고 있지만, 그것들이 주어진 데이터셋이 전부 존재하지는 않을때 유용합니다. 문자형 벡터와는 다르게, 팩터를 표로 만들면 관찰되지 않은 값이라고 해도 모든 카테고리의 수를 얻을 수 있습니다.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb73-1" title="1">sex_char &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;m&quot;</span>, <span class="st">&quot;m&quot;</span>, <span class="st">&quot;m&quot;</span>)</a>
<a class="sourceLine" id="cb73-2" title="2">sex_factor &lt;-<span class="st"> </span><span class="kw">factor</span>(sex_char, <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;m&quot;</span>, <span class="st">&quot;f&quot;</span>))</a>
<a class="sourceLine" id="cb73-3" title="3"></a>
<a class="sourceLine" id="cb73-4" title="4"><span class="kw">table</span>(sex_char)</a>
<a class="sourceLine" id="cb73-5" title="5"><span class="co">#&gt; sex_char</span></a>
<a class="sourceLine" id="cb73-6" title="6"><span class="co">#&gt; m </span></a>
<a class="sourceLine" id="cb73-7" title="7"><span class="co">#&gt; 3</span></a>
<a class="sourceLine" id="cb73-8" title="8"><span class="kw">table</span>(sex_factor)</a>
<a class="sourceLine" id="cb73-9" title="9"><span class="co">#&gt; sex_factor</span></a>
<a class="sourceLine" id="cb73-10" title="10"><span class="co">#&gt; m f </span></a>
<a class="sourceLine" id="cb73-11" title="11"><span class="co">#&gt; 3 0</span></a></code></pre></div>
<p><strong>순서형(Ordered)</strong> 팩터는 팩터를 살짝 변형한 것입니다. 보통은 일반적인 팩터처럼 동작하지만, levels의 순서(low, medium, high)는 의미가 있습니다.(몇몇 모델이나 시각화 함수에서 자동으로 활용됩니다)</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb74-1" title="1">grade &lt;-<span class="st"> </span><span class="kw">ordered</span>(<span class="kw">c</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>), <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;c&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;a&quot;</span>))</a>
<a class="sourceLine" id="cb74-2" title="2">grade</a>
<a class="sourceLine" id="cb74-3" title="3"><span class="co">#&gt; [1] b b a c</span></a>
<a class="sourceLine" id="cb74-4" title="4"><span class="co">#&gt; Levels: c &lt; b &lt; a</span></a></code></pre></div>
<p>Base R에서는 (<code>read.csv()</code>, <code>data.frame()</code>과 같은) 많은 기본 R 함수들이 자동으로 문자형 벡터들을 팩터로 바꿔버리기 때문에, 팩터를 매우 자주 접하게 됩니다. 하지만 이는 차선잭인데, 이러한 함수들이 모든 가능한 levels와 그들의 정확한 순서를 알 도리가 없기 때문입니다. levels는 데이터가 아닌 이론이나 실험 설계의 속성입니다. 대신에, <code>stringAsFactors = FALSE</code> 인자를 사용하면 이러한 현상을 제어할 수 있고, “이론적인” 데이터 지식을 활용해 손수 문자형 벡터들을 팩터로 바꿔줄 수 있습니다. 이에 대한 역사적 맥락을 더 배우고 싶다면, Roger Peng의 <a href="http://simplystatistics.org/2015/07/24/stringsasfactors-an-unauthorized-biography/"><em>stringsAsFactors: An unauthorized
biography</em></a>와, Thomas Lumley의 <a href="http://notstatschat.tumblr.com/post/124987394001/stringsasfactors-sigh"><em>stringsAsFactors =
&lt;sigh&gt;</em></a>를 추천합니다.</p>
<p>비록 팩터가 문자형 벡터처럼 생기고 동작하는 것처럼 보이지만, 정수형 벡터를 기반으로 한다는 것을 기억해야 합니다. 그러니까 이들을 문자열처럼 다룰 때는 주의하세요. <code>gsub()</code>나 <code>grepl()</code> 같은 몇몇 문자형 메소드들은 팩터를 문자열로 강제합니다. <code>nchar()</code>과 같은 애들은 에러를 내기도 하고, <code>c()</code> 같은 애들은 기저에 있는 정수형 벡터를 사용하기도 합니다. 이러한 이유로, 만약 문자열 같은 동작방식이 필요하다면, 명시적으로 팩터를 문자형 벡터로 바꿔 사용하는 것이 최선입니다.</p>
</div>
<div id="dates" class="section level3">
<h3><span class="header-section-number">3.4.2</span> Dates</h3>
<p>날짜 벡터는 실수형(double) 벡터를 기반으로 만들어집니다. 이것들은 “Date” class 속성만을 가집니다.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb75-1" title="1">today &lt;-<span class="st"> </span><span class="kw">Sys.Date</span>()</a>
<a class="sourceLine" id="cb75-2" title="2"></a>
<a class="sourceLine" id="cb75-3" title="3"><span class="kw">typeof</span>(today)</a>
<a class="sourceLine" id="cb75-4" title="4"><span class="co">#&gt; [1] &quot;double&quot;</span></a>
<a class="sourceLine" id="cb75-5" title="5"><span class="kw">attributes</span>(today)</a>
<a class="sourceLine" id="cb75-6" title="6"><span class="co">#&gt; $class</span></a>
<a class="sourceLine" id="cb75-7" title="7"><span class="co">#&gt; [1] &quot;Date&quot;</span></a></code></pre></div>
<p>클래스를 제거하면 볼 수 있는 본래의 실수값은 1970-01-01로부터 흐른 날을 의미합니다.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb76-1" title="1">date &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="st">&quot;1970-02-01&quot;</span>)</a>
<a class="sourceLine" id="cb76-2" title="2"><span class="kw">unclass</span>(date)</a>
<a class="sourceLine" id="cb76-3" title="3"><span class="co">#&gt; [1] 31</span></a></code></pre></div>
</div>
<div id="dates-times" class="section level3">
<h3><span class="header-section-number">3.4.3</span> Dates-times</h3>
<p>Base R은 날짜-시간 정보를 저장할 수 있는 두 방법을 제공합니다. POSIXct와 POSIXlt입니다. 넘나리 이상한 “POSIX”란 이름은 플랫폼 간 표준의 일원인 Portable Operating System Interface의 약자입니다. “ct”는 calendar time(C언어에서 <code>time_t</code> 타입)을, “lt”는 local time(C언어에서 <code>struct tm</code> 타입)을 의미합니다. 여기에서는 <code>POSIXct</code>에 초점을 맞춰보겠습니다. 왜냐하면 이것은 가장 간단하고, atomic vector를 기반으로 만들어졌으며, 데이터 프레임에서 사용하기에 가장 적절하기 때문입니다. POSIXct 벡터는 1970-01-01로부터 흐른 초 수를 표현한 실수값 위에 만들어졌습니다.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb77-1" title="1">now_ct &lt;-<span class="st"> </span><span class="kw">as.POSIXct</span>(<span class="st">&quot;2018-08-01 22:00&quot;</span>, <span class="dt">tz =</span> <span class="st">&quot;UTC&quot;</span>)</a>
<a class="sourceLine" id="cb77-2" title="2">now_ct</a>
<a class="sourceLine" id="cb77-3" title="3"><span class="co">#&gt; [1] &quot;2018-08-01 22:00:00 UTC&quot;</span></a>
<a class="sourceLine" id="cb77-4" title="4"></a>
<a class="sourceLine" id="cb77-5" title="5"><span class="kw">typeof</span>(now_ct)</a>
<a class="sourceLine" id="cb77-6" title="6"><span class="co">#&gt; [1] &quot;double&quot;</span></a>
<a class="sourceLine" id="cb77-7" title="7"><span class="kw">attributes</span>(now_ct)</a>
<a class="sourceLine" id="cb77-8" title="8"><span class="co">#&gt; $class</span></a>
<a class="sourceLine" id="cb77-9" title="9"><span class="co">#&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; </span></a>
<a class="sourceLine" id="cb77-10" title="10"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb77-11" title="11"><span class="co">#&gt; $tzone</span></a>
<a class="sourceLine" id="cb77-12" title="12"><span class="co">#&gt; [1] &quot;UTC&quot;</span></a></code></pre></div>
<p><code>tzone</code> 속성은 날짜-시간이 어떻게 포맷된 것인지를 제어합니다. 벡터에 의해 표현된 시간의 순간을 제어하진 않습니다. 자정이면 시간이 출력되지 않는다는 것은 알아두세요.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb78-1" title="1"><span class="kw">structure</span>(now_ct, <span class="dt">tzone =</span> <span class="st">&quot;Asia/Tokyo&quot;</span>)</a>
<a class="sourceLine" id="cb78-2" title="2"><span class="co">#&gt; [1] &quot;2018-08-02 07:00:00 JST&quot;</span></a>
<a class="sourceLine" id="cb78-3" title="3"><span class="kw">structure</span>(now_ct, <span class="dt">tzone =</span> <span class="st">&quot;America/New_York&quot;</span>)</a>
<a class="sourceLine" id="cb78-4" title="4"><span class="co">#&gt; [1] &quot;2018-08-01 18:00:00 EDT&quot;</span></a>
<a class="sourceLine" id="cb78-5" title="5"><span class="kw">structure</span>(now_ct, <span class="dt">tzone =</span> <span class="st">&quot;Australia/Lord_Howe&quot;</span>)</a>
<a class="sourceLine" id="cb78-6" title="6"><span class="co">#&gt; [1] &quot;2018-08-02 08:30:00 +1030&quot;</span></a>
<a class="sourceLine" id="cb78-7" title="7"><span class="kw">structure</span>(now_ct, <span class="dt">tzone =</span> <span class="st">&quot;Europe/Paris&quot;</span>)</a>
<a class="sourceLine" id="cb78-8" title="8"><span class="co">#&gt; [1] &quot;2018-08-02 CEST&quot;</span></a></code></pre></div>
</div>
<div id="durations" class="section level3">
<h3><span class="header-section-number">3.4.4</span> Durations</h3>
<p>날짜나 날짜-시간 데이터 쌍들 사이의 시간 간격을 의미하는 Durations는 시간차(difftimes) 안에 저장됩니다. Difftimes는 실수형 데이터로 구성되고, 정수가 어떻게 해석되어야 하는지 결정하는 <code>units</code> 속성을 가집니다.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb79-1" title="1">one_week_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">as.difftime</span>(<span class="dv">1</span>, <span class="dt">units =</span> <span class="st">&quot;weeks&quot;</span>)</a>
<a class="sourceLine" id="cb79-2" title="2">one_week_<span class="dv">1</span></a>
<a class="sourceLine" id="cb79-3" title="3"><span class="co">#&gt; Time difference of 1 weeks</span></a>
<a class="sourceLine" id="cb79-4" title="4"></a>
<a class="sourceLine" id="cb79-5" title="5"><span class="kw">typeof</span>(one_week_<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb79-6" title="6"><span class="co">#&gt; [1] &quot;double&quot;</span></a>
<a class="sourceLine" id="cb79-7" title="7"><span class="kw">attributes</span>(one_week_<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb79-8" title="8"><span class="co">#&gt; $class</span></a>
<a class="sourceLine" id="cb79-9" title="9"><span class="co">#&gt; [1] &quot;difftime&quot;</span></a>
<a class="sourceLine" id="cb79-10" title="10"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb79-11" title="11"><span class="co">#&gt; $units</span></a>
<a class="sourceLine" id="cb79-12" title="12"><span class="co">#&gt; [1] &quot;weeks&quot;</span></a>
<a class="sourceLine" id="cb79-13" title="13"></a>
<a class="sourceLine" id="cb79-14" title="14">one_week_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">as.difftime</span>(<span class="dv">7</span>, <span class="dt">units =</span> <span class="st">&quot;days&quot;</span>)</a>
<a class="sourceLine" id="cb79-15" title="15">one_week_<span class="dv">2</span></a>
<a class="sourceLine" id="cb79-16" title="16"><span class="co">#&gt; Time difference of 7 days</span></a>
<a class="sourceLine" id="cb79-17" title="17"></a>
<a class="sourceLine" id="cb79-18" title="18"><span class="kw">typeof</span>(one_week_<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb79-19" title="19"><span class="co">#&gt; [1] &quot;double&quot;</span></a>
<a class="sourceLine" id="cb79-20" title="20"><span class="kw">attributes</span>(one_week_<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb79-21" title="21"><span class="co">#&gt; $class</span></a>
<a class="sourceLine" id="cb79-22" title="22"><span class="co">#&gt; [1] &quot;difftime&quot;</span></a>
<a class="sourceLine" id="cb79-23" title="23"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb79-24" title="24"><span class="co">#&gt; $units</span></a>
<a class="sourceLine" id="cb79-25" title="25"><span class="co">#&gt; [1] &quot;days&quot;</span></a></code></pre></div>
</div>
<div id="exercises-6" class="section level3">
<h3><span class="header-section-number">3.4.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p><code>table()</code>은 어떤 종류의 객체를 반환합니까? 또한 무슨 타입이며, 어떤 속성들을 가집니까? 당신이 더 많은 변수를 표로 만들면 차원은 어떻게 변합니까?</p></li>
<li><p>levels를 수정하면 팩터에 무슨 일이 발생합니까?</p></li>
</ol>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb80-1" title="1">f1 &lt;-<span class="st"> </span><span class="kw">factor</span>(letters)</a>
<a class="sourceLine" id="cb80-2" title="2"><span class="kw">levels</span>(f1) &lt;-<span class="st"> </span><span class="kw">rev</span>(<span class="kw">levels</span>(f1))</a></code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>이 코드는 무엇을 합니까? <code>f2</code>와 <code>f3</code>는 <code>f1</code>과 어떻게 다른가요?</li>
</ol>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb81-1" title="1">f2 &lt;-<span class="st"> </span><span class="kw">rev</span>(<span class="kw">factor</span>(letters))</a>
<a class="sourceLine" id="cb81-2" title="2"></a>
<a class="sourceLine" id="cb81-3" title="3">f3 &lt;-<span class="st"> </span><span class="kw">factor</span>(letters, <span class="dt">levels =</span> <span class="kw">rev</span>(letters))</a></code></pre></div>
</div>
</div>
<div id="lists-1" class="section level2">
<h2><span class="header-section-number">3.5</span> Lists</h2>
<p>리스트는 atomic 벡터에 비해 더 복잡합니다. 각 원소는 벡터 뿐 아니라 어떤 타입이든 될 수 있습니다. 기술적으로 엄밀히 따지면, 리스트의 각 원소들은 사실 같은 타입이긴합니다. Section 2.3.3에서 보았듯이, 각 원소들은 다른 객체(어떤 타입이든 될 수 있는)에 대한 _참조_이기 때문입니다.</p>
<div id="creating" class="section level3">
<h3><span class="header-section-number">3.5.1</span> Creating</h3>
<p><code>list()</code>로 리스트를 만들 수 있습니다.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb82-1" title="1">l1 &lt;-<span class="st"> </span><span class="kw">list</span>(</a>
<a class="sourceLine" id="cb82-2" title="2">  <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, </a>
<a class="sourceLine" id="cb82-3" title="3">  <span class="st">&quot;a&quot;</span>, </a>
<a class="sourceLine" id="cb82-4" title="4">  <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>), </a>
<a class="sourceLine" id="cb82-5" title="5">  <span class="kw">c</span>(<span class="fl">2.3</span>, <span class="fl">5.9</span>)</a>
<a class="sourceLine" id="cb82-6" title="6">)</a>
<a class="sourceLine" id="cb82-7" title="7"></a>
<a class="sourceLine" id="cb82-8" title="8"><span class="kw">typeof</span>(l1)</a>
<a class="sourceLine" id="cb82-9" title="9"><span class="co">#&gt; [1] &quot;list&quot;</span></a>
<a class="sourceLine" id="cb82-10" title="10"></a>
<a class="sourceLine" id="cb82-11" title="11"><span class="kw">str</span>(l1)</a>
<a class="sourceLine" id="cb82-12" title="12"><span class="co">#&gt; List of 4</span></a>
<a class="sourceLine" id="cb82-13" title="13"><span class="co">#&gt;  $ : int [1:3] 1 2 3</span></a>
<a class="sourceLine" id="cb82-14" title="14"><span class="co">#&gt;  $ : chr &quot;a&quot;</span></a>
<a class="sourceLine" id="cb82-15" title="15"><span class="co">#&gt;  $ : logi [1:3] TRUE FALSE TRUE</span></a>
<a class="sourceLine" id="cb82-16" title="16"><span class="co">#&gt;  $ : num [1:2] 2.3 5.9</span></a></code></pre></div>
<p>리스트의 원소는 참조들이라서, 리스트를 만들 때에는 컴포넌트들을 리스트에 복사하지 않아도 됩니다. 따라서 리스트의 총 크기는 예상했던 것보다 아마 작을 것입니다.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb83-1" title="1">lobstr<span class="op">::</span><span class="kw">obj_size</span>(mtcars)</a>
<a class="sourceLine" id="cb83-2" title="2"><span class="co">#&gt; 7,208 B</span></a>
<a class="sourceLine" id="cb83-3" title="3"></a>
<a class="sourceLine" id="cb83-4" title="4">l2 &lt;-<span class="st"> </span><span class="kw">list</span>(mtcars, mtcars, mtcars, mtcars)</a>
<a class="sourceLine" id="cb83-5" title="5">lobstr<span class="op">::</span><span class="kw">obj_size</span>(l2)</a>
<a class="sourceLine" id="cb83-6" title="6"><span class="co">#&gt; 7,288 B</span></a></code></pre></div>
<p>리스트는 복합적인 객체들을 담을 수 있기 때문에, 모든 리스트에 적용될 수 있는 하나의 시각적인 표현법을 고르기는 불가능합니다. 계층을 표현하기 위해 색을 이용하여, 벡터처럼 리스트를 표현해보도록 하겠습니다.</p>
<p><img src="diagrams/vectors/list.png" style="display: block; margin: auto;" /></p>
<p>리스트는 가끔 <strong>재귀(reculsive)</strong> 벡터라고 불리기도 하는데, 리스트는 다른 리스트를 담을 수 있기 때문입니다. 이런 부분이 리스트와 atomic 벡터가 근본적으로 다른 지점입니다.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb84-1" title="1">l3 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="kw">list</span>(<span class="dv">1</span>)))</a>
<a class="sourceLine" id="cb84-2" title="2"><span class="kw">str</span>(l3)</a>
<a class="sourceLine" id="cb84-3" title="3"><span class="co">#&gt; List of 1</span></a>
<a class="sourceLine" id="cb84-4" title="4"><span class="co">#&gt;  $ :List of 1</span></a>
<a class="sourceLine" id="cb84-5" title="5"><span class="co">#&gt;   ..$ :List of 1</span></a>
<a class="sourceLine" id="cb84-6" title="6"><span class="co">#&gt;   .. ..$ : num 1</span></a></code></pre></div>
<p><img src="diagrams/vectors/list-recursive.png" style="display: block; margin: auto;" /></p>
<p><code>c()</code>는 여러 리스트들을 하나로 합쳐줍니다. 만약 atomic 벡터와 리스트의 결합이 주어진다면, <code>c()</code>는 이들을 결합하기 전에 벡터들을 리스트로 강제합니다. <code>list()</code>와 <code>c()</code>의 결과물을 비교해보세요.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb85-1" title="1">l4 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb85-2" title="2">l5 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb85-3" title="3"><span class="kw">str</span>(l4)</a>
<a class="sourceLine" id="cb85-4" title="4"><span class="co">#&gt; List of 2</span></a>
<a class="sourceLine" id="cb85-5" title="5"><span class="co">#&gt;  $ :List of 2</span></a>
<a class="sourceLine" id="cb85-6" title="6"><span class="co">#&gt;   ..$ : num 1</span></a>
<a class="sourceLine" id="cb85-7" title="7"><span class="co">#&gt;   ..$ : num 2</span></a>
<a class="sourceLine" id="cb85-8" title="8"><span class="co">#&gt;  $ : num [1:2] 3 4</span></a>
<a class="sourceLine" id="cb85-9" title="9"><span class="kw">str</span>(l5)</a>
<a class="sourceLine" id="cb85-10" title="10"><span class="co">#&gt; List of 4</span></a>
<a class="sourceLine" id="cb85-11" title="11"><span class="co">#&gt;  $ : num 1</span></a>
<a class="sourceLine" id="cb85-12" title="12"><span class="co">#&gt;  $ : num 2</span></a>
<a class="sourceLine" id="cb85-13" title="13"><span class="co">#&gt;  $ : num 3</span></a>
<a class="sourceLine" id="cb85-14" title="14"><span class="co">#&gt;  $ : num 4</span></a></code></pre></div>
<p><img src="diagrams/vectors/list-c.png" style="display: block; margin: auto;" /></p>
</div>
<div id="testing-and-coercion-1" class="section level3">
<h3><span class="header-section-number">3.5.2</span> Testing and coercion</h3>
<p>리스트의 <code>typeof()</code>는 <code>list</code>입니다. <code>is.list()</code>를 이용해서 리스트인지 테스트할 수 있고, <code>as.list()</code>를 이용해서 리스트로 강제할 수 있습니다.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb86-1" title="1"><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb86-2" title="2"><span class="co">#&gt; [[1]]</span></a>
<a class="sourceLine" id="cb86-3" title="3"><span class="co">#&gt; [1] 1 2 3</span></a>
<a class="sourceLine" id="cb86-4" title="4"><span class="kw">as.list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb86-5" title="5"><span class="co">#&gt; [[1]]</span></a>
<a class="sourceLine" id="cb86-6" title="6"><span class="co">#&gt; [1] 1</span></a>
<a class="sourceLine" id="cb86-7" title="7"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb86-8" title="8"><span class="co">#&gt; [[2]]</span></a>
<a class="sourceLine" id="cb86-9" title="9"><span class="co">#&gt; [1] 2</span></a>
<a class="sourceLine" id="cb86-10" title="10"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb86-11" title="11"><span class="co">#&gt; [[3]]</span></a>
<a class="sourceLine" id="cb86-12" title="12"><span class="co">#&gt; [1] 3</span></a></code></pre></div>
<p><code>unlist()</code>를 사용하면 리스트를 atomic 벡터로 바꿀 수 있습니다. 이 결과에 대한 룰은 복잡하며, 잘 문서화 되어있지도 않고, <code>c()</code>의 결과물가 항상 일치하지도 않습니다.</p>
</div>
<div id="matrices-and-arrays" class="section level3">
<h3><span class="header-section-number">3.5.3</span> Matrices and arrays</h3>
<p>atomic 벡터에서는 차원 속성이 행렬을 만드는 데 흔히 사용됩니다. 리스트에서는 차원 속성을 이용해 리스트-행렬이나 리스트-배열을 만들 수 있습니다.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb87-1" title="1">l &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="st">&quot;a&quot;</span>, <span class="ot">TRUE</span>, <span class="fl">1.0</span>)</a>
<a class="sourceLine" id="cb87-2" title="2"><span class="kw">dim</span>(l) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb87-3" title="3">l</a>
<a class="sourceLine" id="cb87-4" title="4"><span class="co">#&gt;      [,1]      [,2]</span></a>
<a class="sourceLine" id="cb87-5" title="5"><span class="co">#&gt; [1,] Integer,3 TRUE</span></a>
<a class="sourceLine" id="cb87-6" title="6"><span class="co">#&gt; [2,] &quot;a&quot;       1</span></a>
<a class="sourceLine" id="cb87-7" title="7"></a>
<a class="sourceLine" id="cb87-8" title="8">l[[<span class="dv">1</span>, <span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb87-9" title="9"><span class="co">#&gt; [1] 1 2 3</span></a></code></pre></div>
<p>이러한 데이터 구조들은 상대적으로 난해해보이지만, 객체들을 grid-like 구조로 나열하고 싶을 때 유용합니다. 예를 들어, 시공간 grid에 맞추어 모델을 돌리고 싶을 때, 모델들을 grid 구조에 맞는 3D 배열에 저장하는 것이 더 직관적일 수 있습니다.</p>
</div>
<div id="exercises-7" class="section level3">
<h3><span class="header-section-number">3.5.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>리스트가 atomic 벡터와 다른 모든 방식을 나열해보세요.</p></li>
<li><p>리스트를 atomic 벡터로 바꾸기 위해 왜 <code>unlist()</code>를 사용할 필요가 있을까요? 왜 <code>as.vector()</code>는 작동하지 않을까요?</p></li>
<li><p>날짜와 날짜-시간 데이터를 하나의 벡터로 합칠 때, <code>c()</code>와 <code>unlist()</code>를 비교해보세요.</p></li>
</ol>
</div>
</div>
<div id="data-frames-and-tibbles" class="section level2">
<h2><span class="header-section-number">3.6</span> Data frames and tibbles</h2>
<p>리스트를 기반으로 만들어진 가장 중요한 두 S3 벡터는, 데이터 프레임과 티블(tibbles)입니다.</p>
<p><img src="diagrams/vectors/summary-tree-s3-2.png" style="display: block; margin: auto;" /></p>
<p>R로 데이터 분석을 한다면, 데이터 프레임을 이용하게 될 것입니다. 데이터 프레임은 (열)<code>names</code>, <code>row.names()</code> 속성과 “data.frame” 클래스를 가지는 이름 붙여진 리스트입니다.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb88-1" title="1">df1 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])</a>
<a class="sourceLine" id="cb88-2" title="2"><span class="kw">typeof</span>(df1)</a>
<a class="sourceLine" id="cb88-3" title="3"><span class="co">#&gt; [1] &quot;list&quot;</span></a>
<a class="sourceLine" id="cb88-4" title="4"></a>
<a class="sourceLine" id="cb88-5" title="5"><span class="kw">attributes</span>(df1)</a>
<a class="sourceLine" id="cb88-6" title="6"><span class="co">#&gt; $names</span></a>
<a class="sourceLine" id="cb88-7" title="7"><span class="co">#&gt; [1] &quot;x&quot; &quot;y&quot;</span></a>
<a class="sourceLine" id="cb88-8" title="8"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb88-9" title="9"><span class="co">#&gt; $class</span></a>
<a class="sourceLine" id="cb88-10" title="10"><span class="co">#&gt; [1] &quot;data.frame&quot;</span></a>
<a class="sourceLine" id="cb88-11" title="11"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb88-12" title="12"><span class="co">#&gt; $row.names</span></a>
<a class="sourceLine" id="cb88-13" title="13"><span class="co">#&gt; [1] 1 2 3</span></a></code></pre></div>
<p>보통의 리스트와는 다르게, 데이터 프레임에는 추가적인 제한 사항이 있는데, 그것이 가지는 벡터들의 길이가 반드시 같아야 한다는 것입니다. 이 점이 데이터 프레임이 직사각형 구조를 띄게 하고, 이들이 행렬과 리스트의 성질을 동시에 가지는 것을 설명해줍니다.</p>
<ul>
<li><p>데이터 프레임은 <code>rownames()</code>와 <code>colnames()</code>를 갖습니다. 데이터 프레임의 <code>names()</code>는 열 이름을 의미합니다.</p></li>
<li><p>데이터 프레임은 <code>nrow()</code>와 <code>ncol()</code>를 갖습니다. 데이터 프레임의 <code>length()</code>는 열의 수를 뜻합니다.</p></li>
</ul>
<p>데이터 프레임은 R에서 가장 커다랗고 중요한 아이디어 중 하나입니다. 그리고 R을 다른 프로그래밍 언어들과 차별되게 만들어 준 것들 중 하나이죠.</p>
<p>하지만 이것이 만들어진지 20년이 넘게 흘러, 사람들이 R을 사용하는 방식이 변했고, 데이터 프레임이 만들어진 당시에는 괜찮았던 것들이 지금은 문제를 일으키기도 합니다.</p>
<p>이런 문제들이 데이터 프레임을 현대적으로 재디자인한 티블(tibble)의 창조를 이끌었습니다. Tibbles are designed to be (as much as possible) drop-in replacements for data frames that fix those frustrations. 주요한 차이점을 요약하는 간결하고 재미있는 표현은, 티블은 ’게으르(lazy)’고 ’거칠다(surly)’는 것입니다. 이번 Section을 따라가며 무슨 의미인지 보게 될 것입니다.</p>
<p>티블은 티블 패키지에 의해 제공되고 데이터 프레임과 동일한 구조를 공유합니다. 유일한 차이점은 클래스 벡터가 더 길고, <code>tbl_df</code>를 포함하고 있다는 점입니다. 이를 통해 티블이 중요한 방식으로 다르게 동작할 있습니다. 아래에서 더 알아보겠습니다.</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb89-1" title="1"><span class="kw">library</span>(tibble)</a>
<a class="sourceLine" id="cb89-2" title="2"></a>
<a class="sourceLine" id="cb89-3" title="3">df2 &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])</a>
<a class="sourceLine" id="cb89-4" title="4"><span class="kw">typeof</span>(df2)</a>
<a class="sourceLine" id="cb89-5" title="5"><span class="co">#&gt; [1] &quot;list&quot;</span></a>
<a class="sourceLine" id="cb89-6" title="6"></a>
<a class="sourceLine" id="cb89-7" title="7"><span class="kw">attributes</span>(df2)</a>
<a class="sourceLine" id="cb89-8" title="8"><span class="co">#&gt; $names</span></a>
<a class="sourceLine" id="cb89-9" title="9"><span class="co">#&gt; [1] &quot;x&quot; &quot;y&quot;</span></a>
<a class="sourceLine" id="cb89-10" title="10"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb89-11" title="11"><span class="co">#&gt; $row.names</span></a>
<a class="sourceLine" id="cb89-12" title="12"><span class="co">#&gt; [1] 1 2 3</span></a>
<a class="sourceLine" id="cb89-13" title="13"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb89-14" title="14"><span class="co">#&gt; $class</span></a>
<a class="sourceLine" id="cb89-15" title="15"><span class="co">#&gt; [1] &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></a></code></pre></div>
<div id="creating-1" class="section level3">
<h3><span class="header-section-number">3.6.1</span> Creating</h3>
<p><code>data.frame()</code>에 이름 벡터 쌍을 넣어서 데이터 프레임을 생성할 수 있습니다.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb90-1" title="1">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb90-2" title="2">  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, </a>
<a class="sourceLine" id="cb90-3" title="3">  <span class="dt">y =</span> <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)</a>
<a class="sourceLine" id="cb90-4" title="4">)</a>
<a class="sourceLine" id="cb90-5" title="5"><span class="kw">str</span>(df)</a>
<a class="sourceLine" id="cb90-6" title="6"><span class="co">#&gt; &#39;data.frame&#39;:    3 obs. of  2 variables:</span></a>
<a class="sourceLine" id="cb90-7" title="7"><span class="co">#&gt;  $ x: int  1 2 3</span></a>
<a class="sourceLine" id="cb90-8" title="8"><span class="co">#&gt;  $ y: Factor w/ 3 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 1 2 3</span></a></code></pre></div>
<p>디폴트로 문자열을 팩터로 바꿔버리는 것에 주의하세요. <code>stringAsFactors = FALSE</code>를 사용해서 이런 일을 방지하고 문자형 벡터를 문자형 벡터로 보존하세요.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb91-1" title="1">df1 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb91-2" title="2">  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,</a>
<a class="sourceLine" id="cb91-3" title="3">  <span class="dt">y =</span> <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>),</a>
<a class="sourceLine" id="cb91-4" title="4">  <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span></a>
<a class="sourceLine" id="cb91-5" title="5">)</a>
<a class="sourceLine" id="cb91-6" title="6"><span class="kw">str</span>(df1)</a>
<a class="sourceLine" id="cb91-7" title="7"><span class="co">#&gt; &#39;data.frame&#39;:    3 obs. of  2 variables:</span></a>
<a class="sourceLine" id="cb91-8" title="8"><span class="co">#&gt;  $ x: int  1 2 3</span></a>
<a class="sourceLine" id="cb91-9" title="9"><span class="co">#&gt;  $ y: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></a></code></pre></div>
<p>티블을 만드는 것은 데이터 프레임을 만드는 것과 비슷합니다. 둘의 차이점은 티블은 절대 입력값을 강제하지 않는다는 것이죠.(이것이 티블을 ‘게으르게’ 만드는 특징 중 하나입니다)</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb92-1" title="1">df2 &lt;-<span class="st"> </span><span class="kw">tibble</span>(</a>
<a class="sourceLine" id="cb92-2" title="2">  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, </a>
<a class="sourceLine" id="cb92-3" title="3">  <span class="dt">y =</span> <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)</a>
<a class="sourceLine" id="cb92-4" title="4">)</a>
<a class="sourceLine" id="cb92-5" title="5"><span class="kw">str</span>(df2)</a>
<a class="sourceLine" id="cb92-6" title="6"><span class="co">#&gt; Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;:    3 obs. of  2 variables:</span></a>
<a class="sourceLine" id="cb92-7" title="7"><span class="co">#&gt;  $ x: int  1 2 3</span></a>
<a class="sourceLine" id="cb92-8" title="8"><span class="co">#&gt;  $ y: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></a></code></pre></div>
<p>또한 데이터 프레임은 자동으로 non-syntactic한 이름을 바꿔버리지만(<code>check.names = FALSE</code>를 하지 않는한), 티블은 그렇게 하지 않습니다.(대신 non-syntactic한 이름을 <code>`</code>으로 감싸줍니다)</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb93-1" title="1"><span class="kw">names</span>(<span class="kw">data.frame</span>(<span class="st">`</span><span class="dt">1</span><span class="st">`</span> =<span class="st"> </span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb93-2" title="2"><span class="co">#&gt; [1] &quot;X1&quot;</span></a>
<a class="sourceLine" id="cb93-3" title="3"></a>
<a class="sourceLine" id="cb93-4" title="4"><span class="kw">names</span>(<span class="kw">tibble</span>(<span class="st">`</span><span class="dt">1</span><span class="st">`</span> =<span class="st"> </span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb93-5" title="5"><span class="co">#&gt; [1] &quot;1&quot;</span></a></code></pre></div>
<p>데이터 프레임(또는 티블)은 반드시 모든 원소가 같은 길이를 가져야 하지만, <code>data.frame()</code>과 <code>tibble()</code>은 짧은 입력값을 재활용합니다. 하지만 데이터 프레임이 자동으로 정수배로 열들을 재활용하는 반면, 티블은 오직 길이 1짜리 벡터들만 재활용합니다.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb94-1" title="1"><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb94-2" title="2"><span class="co">#&gt;   x y</span></a>
<a class="sourceLine" id="cb94-3" title="3"><span class="co">#&gt; 1 1 1</span></a>
<a class="sourceLine" id="cb94-4" title="4"><span class="co">#&gt; 2 2 2</span></a>
<a class="sourceLine" id="cb94-5" title="5"><span class="co">#&gt; 3 3 1</span></a>
<a class="sourceLine" id="cb94-6" title="6"><span class="co">#&gt; 4 4 2</span></a>
<a class="sourceLine" id="cb94-7" title="7"><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb94-8" title="8"><span class="co">#&gt; Error in data.frame(x = 1:4, y = 1:3): arguments imply differing number of</span></a>
<a class="sourceLine" id="cb94-9" title="9"><span class="co">#&gt; rows: 4, 3</span></a>
<a class="sourceLine" id="cb94-10" title="10"></a>
<a class="sourceLine" id="cb94-11" title="11"><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">y =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb94-12" title="12"><span class="co">#&gt; # A tibble: 4 x 2</span></a>
<a class="sourceLine" id="cb94-13" title="13"><span class="co">#&gt;       x     y</span></a>
<a class="sourceLine" id="cb94-14" title="14"><span class="co">#&gt;   &lt;int&gt; &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb94-15" title="15"><span class="co">#&gt; 1     1     1</span></a>
<a class="sourceLine" id="cb94-16" title="16"><span class="co">#&gt; 2     2     1</span></a>
<a class="sourceLine" id="cb94-17" title="17"><span class="co">#&gt; 3     3     1</span></a>
<a class="sourceLine" id="cb94-18" title="18"><span class="co">#&gt; 4     4     1</span></a>
<a class="sourceLine" id="cb94-19" title="19"><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb94-20" title="20"><span class="co">#&gt; Error: Tibble columns must have consistent lengths, only values of length one</span></a>
<a class="sourceLine" id="cb94-21" title="21"><span class="co">#&gt; are recycled:</span></a>
<a class="sourceLine" id="cb94-22" title="22"><span class="co">#&gt; * Length 2: Column `y`</span></a>
<a class="sourceLine" id="cb94-23" title="23"><span class="co">#&gt; * Length 4: Column `x`</span></a></code></pre></div>
<p>마지막 차이점은, <code>tibble()</code>은 티블을 생성하는 도중에 만들어진 변수를 참조할 수 있다는 것입니다.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb95-1" title="1"><span class="kw">tibble</span>(</a>
<a class="sourceLine" id="cb95-2" title="2">  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,</a>
<a class="sourceLine" id="cb95-3" title="3">  <span class="dt">y =</span> x <span class="op">*</span><span class="st"> </span><span class="dv">2</span></a>
<a class="sourceLine" id="cb95-4" title="4">)</a>
<a class="sourceLine" id="cb95-5" title="5"><span class="co">#&gt; # A tibble: 3 x 2</span></a>
<a class="sourceLine" id="cb95-6" title="6"><span class="co">#&gt;       x     y</span></a>
<a class="sourceLine" id="cb95-7" title="7"><span class="co">#&gt;   &lt;int&gt; &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb95-8" title="8"><span class="co">#&gt; 1     1     2</span></a>
<a class="sourceLine" id="cb95-9" title="9"><span class="co">#&gt; 2     2     4</span></a>
<a class="sourceLine" id="cb95-10" title="10"><span class="co">#&gt; 3     3     6</span></a></code></pre></div>
<p>(입력값은 왼쪽에서 오른쪽으로 계산됩니다.)</p>
<p>데이터 프레임과 티블을 그릴 때, 속성 같은 내부적 디테일들에 집중하기 보단,</p>
<p><img src="diagrams/vectors/data-frame-1.png" style="display: block; margin: auto;" /></p>
<p>이름 붙인 리스트와 같은 방식으로 표현하겠습니다. 대신 이들의 컬럼 구조를 강조해주겠습니다.</p>
<p><img src="diagrams/vectors/data-frame-2.png" style="display: block; margin: auto;" /></p>
</div>
<div id="row-names" class="section level3">
<h3><span class="header-section-number">3.6.2</span> Row names</h3>
<p>데이터 프레임에서는 각 행에 이름을 붙일 수 있습니다. 문자형 벡터는 고유한 값들만을 담아야합니다.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb96-1" title="1">df3 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb96-2" title="2">  <span class="dt">age =</span> <span class="kw">c</span>(<span class="dv">35</span>, <span class="dv">27</span>, <span class="dv">18</span>),</a>
<a class="sourceLine" id="cb96-3" title="3">  <span class="dt">hair =</span> <span class="kw">c</span>(<span class="st">&quot;blond&quot;</span>, <span class="st">&quot;brown&quot;</span>, <span class="st">&quot;black&quot;</span>),</a>
<a class="sourceLine" id="cb96-4" title="4">  <span class="dt">row.names =</span> <span class="kw">c</span>(<span class="st">&quot;Bob&quot;</span>, <span class="st">&quot;Susan&quot;</span>, <span class="st">&quot;Sam&quot;</span>)</a>
<a class="sourceLine" id="cb96-5" title="5">)</a>
<a class="sourceLine" id="cb96-6" title="6">df3</a>
<a class="sourceLine" id="cb96-7" title="7"><span class="co">#&gt;       age  hair</span></a>
<a class="sourceLine" id="cb96-8" title="8"><span class="co">#&gt; Bob    35 blond</span></a>
<a class="sourceLine" id="cb96-9" title="9"><span class="co">#&gt; Susan  27 brown</span></a>
<a class="sourceLine" id="cb96-10" title="10"><span class="co">#&gt; Sam    18 black</span></a></code></pre></div>
<p><code>rownames()</code>로 행 이름을 확인하거나 설정할 수 있고, 이를 행을 추출할 때 사용할 수 있습니다.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb97-1" title="1"><span class="kw">rownames</span>(df3)</a>
<a class="sourceLine" id="cb97-2" title="2"><span class="co">#&gt; [1] &quot;Bob&quot;   &quot;Susan&quot; &quot;Sam&quot;</span></a>
<a class="sourceLine" id="cb97-3" title="3"></a>
<a class="sourceLine" id="cb97-4" title="4">df3[<span class="st">&quot;Bob&quot;</span>, ]</a>
<a class="sourceLine" id="cb97-5" title="5"><span class="co">#&gt;     age  hair</span></a>
<a class="sourceLine" id="cb97-6" title="6"><span class="co">#&gt; Bob  35 blond</span></a></code></pre></div>
<p>데이터 프레임을 행렬과 같은 2차원 구조라고 생각하면 행 이름은 자연스운 것입니다. 열(변수)가 이름이 있으니, 행(관측치)도 있어야 하는게 당연해보이죠. 행렬은 대개 숫자형입니다. 때문에 문자 레이블을 저장할 장소를 마련하는게 중요하죠. 하지만 행렬로부터 이렇게 유추하는 것은 오해의 소지가 있습니다. 왜냐하면 행렬은 데이터 프레임에겐 없는 중요한 특징을 갖고 있기 때문입니다. 바로 ’전치(transpose)’가 가능하단 점입니다. 행렬에선 행과 열이 상호 교환가능합니다. 또 행렬을 전치시키면 다른 행렬이 됩니다.(다시 전치시키면 원래의 행렬을 얻게 되겠죠) 하지만 데이터 프레임은 행과 열이 교환가능하지 않습니다. 데이터 프레임을 전치시키면 데이터 프레임이 아니게 됩니다.</p>
<p>행 이름은 사용하지 않는 것이 바람직한데, 이에는 세 가지 이유가 있습니다.</p>
<ul>
<li><p>메타데이터는 그 자체로 데이터입니다. 그렇기 때문에, 다른 데이터와 다른 방식으로 저장하려고 하는 것은 근본적으로 안 좋은 아이디어입니다. 또한 열을 다루기 위해 당신이 기존에 가지고 있는 지식을 활용할 수 없게되니, 행 이름만을 작업하기 위해 새로운 도구들을 배워야만 한다는 의미도 되겠죠.</p></li>
<li><p>행 이름은 행을 라벨링하는 방식 중 아주 별로인 방법입니다. 왜냐하면 행이 하나의 문자열에 의해서 식별 가능할 때에만 작동하기 때문입니다. 이는 많은 상황에서 실패할텐데, 예를 들면 어느 ’시점’과 같은 문자열이 아닌 벡터에 의해 행이 식별되기 원할 때나, 경도 위도로 표현된 위치 같은 여러 벡터로 식별되어야 할 때 등이 있겠습니다.</p></li>
<li><p>행 이름은 반드시 고유해야 합니다. 그래서 중복되는 행이 있으면(부트스트래핑에서 왔다든지) 새로운 행 이름이 만들어집니다. 만약 변환하기 전 후의 행을 일치시키려면 골치아픈 문자열 작업을 해야만 할 겁니다.</p></li>
</ul>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb98-1" title="1">df3[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>), ]</a>
<a class="sourceLine" id="cb98-2" title="2"><span class="co">#&gt;       age  hair</span></a>
<a class="sourceLine" id="cb98-3" title="3"><span class="co">#&gt; Bob    35 blond</span></a>
<a class="sourceLine" id="cb98-4" title="4"><span class="co">#&gt; Bob.1  35 blond</span></a>
<a class="sourceLine" id="cb98-5" title="5"><span class="co">#&gt; Bob.2  35 blond</span></a></code></pre></div>
<p>이러한 이유 때문에 티블은 행 이름을 지원하지 않습니다. 대신에 티블 패키지는 손쉽게 행 이름을 일반적인 열로 변화시킬 수 있는 <code>rownames_to_column()</code>이나 <code>as_tibble()</code>의 <code>rownames</code> 인자 같은 툴을 제공합니다.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb99-1" title="1"><span class="kw">as_tibble</span>(df3, <span class="dt">rownames =</span> <span class="st">&quot;name&quot;</span>)</a>
<a class="sourceLine" id="cb99-2" title="2"><span class="co">#&gt; # A tibble: 3 x 3</span></a>
<a class="sourceLine" id="cb99-3" title="3"><span class="co">#&gt;   name    age hair </span></a>
<a class="sourceLine" id="cb99-4" title="4"><span class="co">#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt;</span></a>
<a class="sourceLine" id="cb99-5" title="5"><span class="co">#&gt; 1 Bob      35 blond</span></a>
<a class="sourceLine" id="cb99-6" title="6"><span class="co">#&gt; 2 Susan    27 brown</span></a>
<a class="sourceLine" id="cb99-7" title="7"><span class="co">#&gt; 3 Sam      18 black</span></a></code></pre></div>
</div>
<div id="printing" class="section level3">
<h3><span class="header-section-number">3.6.3</span> Printing</h3>
<p>티블과 데이터 프레임의 가장 명확한 차이점 중 하나는 그들이 출력되는 방식입니다. 아마 여러분은 데이터 프레임이 어떻게 출력되는 지는 익숙하실 겁니다. dplyr 패키지에 들어있는 예제 데이터를 사용해서 가장 큰 차이점을 보여드리겠습니다.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb100-1" title="1">dplyr<span class="op">::</span>starwars</a>
<a class="sourceLine" id="cb100-2" title="2"><span class="co">#&gt; # A tibble: 87 x 13</span></a>
<a class="sourceLine" id="cb100-3" title="3"><span class="co">#&gt;    name  height  mass hair_color skin_color eye_color birth_year gender</span></a>
<a class="sourceLine" id="cb100-4" title="4"><span class="co">#&gt;    &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; </span></a>
<a class="sourceLine" id="cb100-5" title="5"><span class="co">#&gt;  1 Luke…    172    77 blond      fair       blue            19   male  </span></a>
<a class="sourceLine" id="cb100-6" title="6"><span class="co">#&gt;  2 C-3PO    167    75 &lt;NA&gt;       gold       yellow         112   &lt;NA&gt;  </span></a>
<a class="sourceLine" id="cb100-7" title="7"><span class="co">#&gt;  3 R2-D2     96    32 &lt;NA&gt;       white, bl… red             33   &lt;NA&gt;  </span></a>
<a class="sourceLine" id="cb100-8" title="8"><span class="co">#&gt;  4 Dart…    202   136 none       white      yellow          41.9 male  </span></a>
<a class="sourceLine" id="cb100-9" title="9"><span class="co">#&gt;  5 Leia…    150    49 brown      light      brown           19   female</span></a>
<a class="sourceLine" id="cb100-10" title="10"><span class="co">#&gt;  6 Owen…    178   120 brown, gr… light      blue            52   male  </span></a>
<a class="sourceLine" id="cb100-11" title="11"><span class="co">#&gt;  7 Beru…    165    75 brown      light      blue            47   female</span></a>
<a class="sourceLine" id="cb100-12" title="12"><span class="co">#&gt;  8 R5-D4     97    32 &lt;NA&gt;       white, red red             NA   &lt;NA&gt;  </span></a>
<a class="sourceLine" id="cb100-13" title="13"><span class="co">#&gt;  9 Bigg…    183    84 black      light      brown           24   male  </span></a>
<a class="sourceLine" id="cb100-14" title="14"><span class="co">#&gt; 10 Obi-…    182    77 auburn, w… fair       blue-gray       57   male  </span></a>
<a class="sourceLine" id="cb100-15" title="15"><span class="co">#&gt; # … with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,</span></a>
<a class="sourceLine" id="cb100-16" title="16"><span class="co">#&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;</span></a></code></pre></div>
<ul>
<li><p>티블은 첫 10개 행과 스크린에 맞는 열들만을 보여줍니다. 추가 열들은 아래에 보여집니다.</p></li>
<li><p>각 열들은 세, 네글자로 축약된 타입 이름과 함께 표기됩니다.</p></li>
<li><p>하나의 긴 문자열이 행 전체를 차지해버리는 것을 방지하기 위해, 넓은(관측치 길이가 긴) 열들은 잘립니다.</p></li>
<li><p>지원되는 콘솔 환경에서 사용할 때, 중요한 정보를 강조하거나 덜 중요한 세부 사항을 강조하지 않기 위해, 신중하게 색깔이 표현됩니다.</p></li>
</ul>
</div>
<div id="subsetting" class="section level3">
<h3><span class="header-section-number">3.6.4</span> Subsetting</h3>
<p>Chapter 4에서 배우겠지만, 데이터 프레임이나 티블은 1D 구조(리스트처럼 동작하는)처럼 서브셋하거나, 2D 구조(행렬처럼 동작하는)처럼 서브셋할 수 있습니다.</p>
<p>제 생각엔, 데이터 프레임에게는 바람직하지 못한 서브셋 작동방식 두 가지가 있습니다.</p>
<ul>
<li><p><code>df[, vars]</code>로 열을 서브셋할 때, <code>vars</code>가 한 개 변수를 선택하면 벡터를 얻게 되고, 그렇지 않으면 데이터 프레임을 얻게 됩니다. 만약 <code>df[, vars, drop = FALSE]</code>를 사용하는 것을 항상 기억하지 않는 한, 함수에 <code>[</code>를 사용하는 것은 잦은 버그의 원인이 됩니다.</p></li>
<li><p><code>df$x</code>로 열 하나를 뽑아내려는데 <code>x</code>라는 열이 없다면, 대신 데이터 프레임은 <code>x</code>로 시작하는 아무 변수나 골라줍니다. 만약 <code>x</code>로 시작하는 변수가 없으면, <code>df$x</code>는 <code>NULL</code>을 반환합니다. 이는 잘못된 변수나 존재하지 않는 변수를 선택하기 쉬워집니다.</p></li>
</ul>
<p>티블은 이러한 작동 방식을 비틀었습니다. <code>[</code>는 항상 티블을 반환하고, <code>$</code>는 부분적으로 매칭시키지 않고 만약 변수를 찾을 수 없으면 경고를 해줍니다.(이 부분이 티블을 surly하게 합니다)</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb101-1" title="1">df1 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">xyz =</span> <span class="st">&quot;a&quot;</span>)</a>
<a class="sourceLine" id="cb101-2" title="2">df2 &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">xyz =</span> <span class="st">&quot;a&quot;</span>)</a>
<a class="sourceLine" id="cb101-3" title="3"></a>
<a class="sourceLine" id="cb101-4" title="4"><span class="kw">str</span>(df1<span class="op">$</span>x)</a>
<a class="sourceLine" id="cb101-5" title="5"><span class="co">#&gt;  Factor w/ 1 level &quot;a&quot;: 1</span></a>
<a class="sourceLine" id="cb101-6" title="6"><span class="kw">str</span>(df2<span class="op">$</span>x)</a>
<a class="sourceLine" id="cb101-7" title="7"><span class="co">#&gt; Warning: Unknown or uninitialised column: &#39;x&#39;.</span></a>
<a class="sourceLine" id="cb101-8" title="8"><span class="co">#&gt;  NULL</span></a></code></pre></div>
<p><code>[</code>에서 데이터 프레임만을 반환하는 티블의 성질 때문에 레거시 코드(<code>df[, "col"]</code>으로 한 열을 추출하는 식)에서 문제가 생기기도 합니다. 만약 열 하나를 원한다면 <code>df[["col"]]</code>을 사용하길 권장드립니다. 이는 의도를 분명히 전달할 수 있고, 데이터 프레임과 티블 둘 다 작동합니다.</p>
</div>
<div id="testing-and-coercing" class="section level3">
<h3><span class="header-section-number">3.6.5</span> Testing and coercing</h3>
<p>객체가 데이터 프레임이나 티블인 것을 확인하려면, <code>is.data.frame()</code>을 사용하세요.</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb102-1" title="1"><span class="kw">is.data.frame</span>(df1)</a>
<a class="sourceLine" id="cb102-2" title="2"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb102-3" title="3"><span class="kw">is.data.frame</span>(df2)</a>
<a class="sourceLine" id="cb102-4" title="4"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
<p>일반적으로는 티블이든 데이터 프레임이든 문제가 되지 않습니다만, 만약 확실히 해야하는 상황이라면, <code>is_tibble()</code>을 이용하세요.</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb103-1" title="1"><span class="kw">is_tibble</span>(df1)</a>
<a class="sourceLine" id="cb103-2" title="2"><span class="co">#&gt; [1] FALSE</span></a>
<a class="sourceLine" id="cb103-3" title="3"><span class="kw">is_tibble</span>(df2)</a>
<a class="sourceLine" id="cb103-4" title="4"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
<p><code>as.data.frame()</code>은 데이터 프레임으로, <code>as_tibble()</code>은 티블로 객체를 강제시켜줍니다.</p>
</div>
<div id="list-columns" class="section level3">
<h3><span class="header-section-number">3.6.6</span> List columns</h3>
<p>데이터 프레임은 백터들의 리스트이기 때문에, 데이터 프레임이 리스트인 열을 갖는 것도 가능합니다. 리스트는 어떤 객체든 담을 수 있기 때문에 이는 매우 유용합니다. 데이터 프레임에 어떤 종류의 객체든 넣을 수 있다는 뜻입니다. 개별 객체가 얼마나 복잡한지는 상관없이, 연관된 객체들을 행에 함께 넣을 수 있습니다. <em>R for Data Science</em>, <a href="http://r4ds.had.co.nz/many-models.html" class="uri">http://r4ds.had.co.nz/many-models.html</a>의 “Many Models” chapter에서 이 응용을 보실 수 있습니다.</p>
<p>데이터 프레임에서 리스트인 열이 허용되긴 하지만, 데이터 프레임을 만들고나서 리스트 열을 추가하거나, 리스트를 <code>I()</code>로 래핑하는 방식을 이용해 추가적으로 수고해줘야 합니다.</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb104-1" title="1">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb104-2" title="2">df<span class="op">$</span>y &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>)</a>
<a class="sourceLine" id="cb104-3" title="3"></a>
<a class="sourceLine" id="cb104-4" title="4"><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb104-5" title="5">  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, </a>
<a class="sourceLine" id="cb104-6" title="6">  <span class="dt">y =</span> <span class="kw">I</span>(<span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>))</a>
<a class="sourceLine" id="cb104-7" title="7">)</a>
<a class="sourceLine" id="cb104-8" title="8"><span class="co">#&gt;   x          y</span></a>
<a class="sourceLine" id="cb104-9" title="9"><span class="co">#&gt; 1 1       1, 2</span></a>
<a class="sourceLine" id="cb104-10" title="10"><span class="co">#&gt; 2 2    1, 2, 3</span></a>
<a class="sourceLine" id="cb104-11" title="11"><span class="co">#&gt; 3 3 1, 2, 3, 4</span></a></code></pre></div>
<p><img src="diagrams/vectors/data-frame-list.png" style="display: block; margin: auto;" /></p>
<p>리스트 열은 티블과 함께 사용하기 더 쉽습니다. <code>tibble()</code> 내부에 직접 넣을 수 있고, 깔끔하게 출력되기 때문입니다.</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb105-1" title="1"><span class="kw">tibble</span>(</a>
<a class="sourceLine" id="cb105-2" title="2">  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, </a>
<a class="sourceLine" id="cb105-3" title="3">  <span class="dt">y =</span> <span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>)</a>
<a class="sourceLine" id="cb105-4" title="4">)</a>
<a class="sourceLine" id="cb105-5" title="5"><span class="co">#&gt; # A tibble: 3 x 2</span></a>
<a class="sourceLine" id="cb105-6" title="6"><span class="co">#&gt;       x y        </span></a>
<a class="sourceLine" id="cb105-7" title="7"><span class="co">#&gt;   &lt;int&gt; &lt;list&gt;   </span></a>
<a class="sourceLine" id="cb105-8" title="8"><span class="co">#&gt; 1     1 &lt;int [2]&gt;</span></a>
<a class="sourceLine" id="cb105-9" title="9"><span class="co">#&gt; 2     2 &lt;int [3]&gt;</span></a>
<a class="sourceLine" id="cb105-10" title="10"><span class="co">#&gt; 3     3 &lt;int [4]&gt;</span></a></code></pre></div>
</div>
<div id="matrix-and-data-frame-columns" class="section level3">
<h3><span class="header-section-number">3.6.7</span> Matrix and data frame columns</h3>
<p>행 수가 데이터 프레임과 맞기만 하다면, 행렬이나 배열을 데이터 프레임의 열로 갖는 것도 가능합니다.(이는 데이터 프레임에 대한 정의를 조금 더 확장시켜야 합니다: 각 열에 대한 <code>length()</code>가 아닌 <code>NROW()</code>가 일치해야 합니다) 리스트 열과 마찬가지로, 만들고 추가시켜주거나 <code>I()</code>로 래핑해줘야 합니다.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb106-1" title="1">dfm &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb106-2" title="2">  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span> <span class="op">*</span><span class="st"> </span><span class="dv">10</span></a>
<a class="sourceLine" id="cb106-3" title="3">)</a>
<a class="sourceLine" id="cb106-4" title="4">dfm<span class="op">$</span>y &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>, <span class="dt">nrow =</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb106-5" title="5">dfm<span class="op">$</span>z &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">b =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>], <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb106-6" title="6"></a>
<a class="sourceLine" id="cb106-7" title="7"><span class="kw">str</span>(dfm)</a>
<a class="sourceLine" id="cb106-8" title="8"><span class="co">#&gt; &#39;data.frame&#39;:    3 obs. of  3 variables:</span></a>
<a class="sourceLine" id="cb106-9" title="9"><span class="co">#&gt;  $ x: num  10 20 30</span></a>
<a class="sourceLine" id="cb106-10" title="10"><span class="co">#&gt;  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9</span></a>
<a class="sourceLine" id="cb106-11" title="11"><span class="co">#&gt;  $ z:&#39;data.frame&#39;:   3 obs. of  2 variables:</span></a>
<a class="sourceLine" id="cb106-12" title="12"><span class="co">#&gt;   ..$ a: int  3 2 1</span></a>
<a class="sourceLine" id="cb106-13" title="13"><span class="co">#&gt;   ..$ b: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></a></code></pre></div>
<p><img src="diagrams/vectors/data-frame-matrix.png" style="display: block; margin: auto;" /></p>
<p>행렬과 데이터 프레임 열들은 조금 주의해야합니다. 데이터 프레임에 작동하는 많은 함수들은 모든 열들이 벡터인 것을 전제로 합니다. 또한 출력된 화면이 좀 헷갈릴 수 있습니다.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb107-1" title="1">dfm[<span class="dv">1</span>, ]</a>
<a class="sourceLine" id="cb107-2" title="2"><span class="co">#&gt;    x y.1 y.2 y.3 z.a z.b</span></a>
<a class="sourceLine" id="cb107-3" title="3"><span class="co">#&gt; 1 10   1   4   7   3   a</span></a></code></pre></div>
</div>
<div id="exercises-8" class="section level3">
<h3><span class="header-section-number">3.6.8</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>행이나 열 수가 0인 데이터 프레임을 만들 수 있습니까?</p></li>
<li><p>만약 고유하지 않은 행 이름을 설정하려고 시도하면 어떻게 되나요?</p></li>
<li><p>만약 <code>df</code>가 데이터 프레임이라면 <code>t(df)</code>와 <code>t(t(df))</code>를 어떻게 설명할까요? 여러 열 타입들에 대해서 한 번 실험해 보세요.</p></li>
<li><p><code>as.matrix()</code>를 서로 다른 타입의 열들을 가진 데이터 프레임에 적용하면 어떻게 되나요? <code>data.matrix()</code>와는 무엇이 다른가요?</p></li>
</ol>
</div>
</div>
<div id="null" class="section level2">
<h2><span class="header-section-number">3.7</span> NULL</h2>
<p>이 Chapter를 마무리하며, 마지막으로 벡터와 연관된 중요한 데이터 구조 하나를 소개하려고 합니다. <code>NULL</code>은 특별합니다. 왜냐하면 얘는 그 자체로 고유한 타입이고, 항상 길이가 0이며, 어떤 속성도 가질 수 없기 때문입니다.</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb108-1" title="1"><span class="kw">typeof</span>(<span class="ot">NULL</span>)</a>
<a class="sourceLine" id="cb108-2" title="2"><span class="co">#&gt; [1] &quot;NULL&quot;</span></a>
<a class="sourceLine" id="cb108-3" title="3"></a>
<a class="sourceLine" id="cb108-4" title="4"><span class="kw">length</span>(<span class="ot">NULL</span>)</a>
<a class="sourceLine" id="cb108-5" title="5"><span class="co">#&gt; [1] 0</span></a>
<a class="sourceLine" id="cb108-6" title="6"></a>
<a class="sourceLine" id="cb108-7" title="7">x &lt;-<span class="st"> </span><span class="ot">NULL</span></a>
<a class="sourceLine" id="cb108-8" title="8"><span class="kw">attr</span>(x, <span class="st">&quot;y&quot;</span>) &lt;-<span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb108-9" title="9"><span class="co">#&gt; Error in attr(x, &quot;y&quot;) &lt;- 1: NULL 객체에 속성부여를 시도했습니다</span></a></code></pre></div>
<p><code>is.null()</code>을 이용해서 <code>NULL</code> 테스트를 할 수 있습니다.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb109-1" title="1"><span class="kw">is.null</span>(<span class="ot">NULL</span>)</a>
<a class="sourceLine" id="cb109-2" title="2"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
<p><code>NULL</code>은 흔히 두 가지로 활용할 수 있습니다.</p>
<ul>
<li>임의의 빈 벡터(길이가 0인 벡터)를 표현하기 위해 사용할 수 있습니다. 예를 들어, 어떤 인자도 들어있지 않은 <code>c()</code>를 사용하면 <code>NULL</code>을 얻게 되고, 벡터와 <code>NULL</code>을 결합하면 변화가 일어나지 않습니다.</li>
</ul>
<div class="sourceCode" id="cb110"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb110-1" title="1"><span class="kw">c</span>()</a>
<a class="sourceLine" id="cb110-2" title="2"><span class="co">#&gt; NULL</span></a></code></pre></div>
<ul>
<li>누락된 벡터를 표현하기 위해 사용할 수 있습니다. 예를 들면 <code>NULL</code>은 인자가 선택적이지만, 디폴트 값이 연산을 요구할 경우, 함수의 디폴트 인자로 사용되곤 합니다.(Section 6.5.3에서 더 알아봅시다) <code>NA</code>는 벡터의 _원소_가 비어있는 것을 가리킬 때 사용됩니다.</li>
</ul>
<p>만약 SQL에 익숙하다면, 관계적인 <code>NULL</code>에 대해 아실텐데, 이는 R의 것과 같을 거라고 예상하실지도 모르겠습니다. 하지만 데이터 베이스에서의 <code>NULL</code>은 R의 <code>NA</code>와 같은 개념입니다.</p>
</div>
<div id="quiz-answers-1" class="section level2">
<h2><span class="header-section-number">3.8</span> Quiz answers</h2>
<ol style="list-style-type: decimal">
<li><p>atomic 벡터의 네가지 기본 타입은 논리형, 정수형, 실수형, 문자형입니다. 두가지 희귀 타입은 복소수형과 raw 타입입니다.</p></li>
<li><p>속성은 어떤 객체에든 임의의 추가적인 메타 데이터를 더할 수 있게 해줍니다. <code>attr(x, "y")</code>과 <code>attr(x, "y") &lt;- value</code>를 이용해서 개별 속성 값에 접근하거나 설정할 수 있습니다. 또는 <code>attribute()</code>로 한 번에 모든 속성값을 얻거나 설정할 수 있습니다.</p></li>
<li><p>리스트의 원소는 어떤 타입(심지어 리스트도)이든 될 수 있고, atomic 벡터의 원소는 모두 같은 타입이어야 합니다. 유사하게, 행렬의 모든 원소는 같은 타입이어야 하고, 데이터 프레임에서는 각 열들이 다른 타입을 가질 수 있습니다.</p></li>
<li><p>리스트에 차원을 부여하면 리스트-배열을 만들 수 있습니다. <code>df$x &lt;- matrix()</code>나 <code>data.frame(x = I(matrix()))</code>와 같이 새로운 데이터 프레임을 만들 때 <code>I()</code>를 사용해서, 행렬을 데이터 프레임의 열로 만들 수 있습니다.</p></li>
<li><p>티블은 향상된 출력 방식을 가지며, 문자열을 팩터로 강제하지 않고, 엄격한 서브세팅 방식을 사용합니다.</p></li>
</ol>
</div>
<div id="summary-1" class="section level2">
<h2><span class="header-section-number">3.9</span> Summary</h2>
<ul>
<li><p>벡터는 크게 atomic 벡터(same type)와 리스트(no matter)로 구성됨</p></li>
<li><p>우리가 아는 다른 데이터 구조들은 바로 위의 벡터에 attributes를 추가한 것임</p></li>
<li><p>Matrix, Array = Vector + &lt; dimensions &gt;</p></li>
<li><p>Factor = Integer + &lt; factor class, levels &gt;</p></li>
<li><p>Dataframe = List + &lt; data.frame class, names &gt;</p></li>
<li><p>Tibble : strings as factors + non-syntactic variable name + recycling rule + varible references</p></li>
<li><p>NULL : a vector is absent / NA : an element of a vector is absent</p></li>
</ul>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="names-values.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page"><i class="fa fa-angle-left"></i></a>

    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
